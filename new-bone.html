<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Angelus Novus: Spinning Sound Synth</title>
    <link rel="icon" href="data:," />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        html, body {
            height: 100%;
        }
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
        }
        
        #container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }
        /* Prefer dynamic viewport on modern mobile browsers to avoid toolbar collapse issues */
        @supports (height: 100dvh) {
          #container { height: 100dvh; }
        }
        /* iOS fallback when dynamic viewport not available */
        @supports (-webkit-touch-callout: none) {
          html, body { height: -webkit-fill-available; }
          #container { height: -webkit-fill-available; }
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none; /* Prevents default touch actions */
        }

        #info-overlay {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: #b366ff;
            padding: 10px 20px;
            border-radius: 10px;
            font-family: 'Arial', sans-serif;
            font-size: 14px;
            transition: opacity 0.5s ease-in-out;
            user-select: none;
            z-index: 100;
        }
        
        #controls-panel {
            position: absolute;
            top: 24px;
            right: 24px;
            background: rgba(20, 20, 25, 0.5);
            backdrop-filter: blur(10px) saturate(120%);
            -webkit-backdrop-filter: blur(10px) saturate(120%);
            padding: 12px;
            border-radius: 14px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            transition: transform 0.3s ease-in-out, opacity 0.3s;
            transform: translateX(120%);
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 8px;
            user-select: none;
            font-family: Inter, system-ui, -apple-system, Arial, sans-serif;
        }

        #controls-panel.active {
            transform: translateX(0);
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.08);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.12);
            padding: 8px 12px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 14px;
            min-width: 44px;
            min-height: 36px;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s, transform 0.15s, box-shadow 0.2s, border-color 0.2s;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.25);
        }
        
        .control-btn:hover {
            background: rgba(255, 255, 255, 0.16);
            transform: translateY(-1px);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .control-btn.active {
            background: #8a2be2;
            box-shadow: 0 0 12px rgba(138, 43, 226, 0.6);
            border-color: rgba(138, 43, 226, 0.6);
        }
        
        .control-btn.recording {
            background: #f44336;
            animation: pulse 1s infinite;
        }

        #toggle-controls-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.08);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.12);
            padding: 8px 12px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 14px;
            z-index: 101;
            transition: transform 0.2s, background-color 0.2s, border-color 0.2s;
        }

        #toggle-controls-btn:hover {
            background: rgba(255, 255, 255, 0.16);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .slider-group {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 6px;
        }
        .slider-group label {
            color: #ddd;
            font-size: 12px;
            letter-spacing: 0.04em;
        }
        .slider-group input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 140px;
            height: 4px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 999px;
            outline: none;
        }
        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #8a2be2;
            box-shadow: 0 0 0 4px rgba(138, 43, 226, 0.25);
            cursor: pointer;
        }
        .slider-group input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #8a2be2;
            box-shadow: 0 0 0 4px rgba(138, 43, 226, 0.25);
            cursor: pointer;
        }
        
        #help-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            z-index: 200;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease-in-out, visibility 0.5s;
        }

        #help-screen h2 {
            font-size: 2em;
            margin-bottom: 20px;
        }

        #help-screen ul {
            list-style: none;
            padding: 0;
            text-align: left;
            max-width: 600px;
            font-size: 1.2em;
        }

        #help-screen li {
            margin-bottom: 15px;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
        }

        .note-label {
            position: absolute;
            color: #ff00ff;
            font-family: 'Arial', sans-serif;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            transform: translate(-50%, -50%);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="container">
        <!-- 3D Scene Canvas is added by JS -->
    </div>

    <!-- Roster Modal (kept but unused in this version) -->
    <div id="roster-modal" style="position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:300;">
        <div style="position:absolute; inset:0; background:rgba(0,0,0,0.6);" id="roster-modal-bg"></div>
        <div style="position:relative; width:min(96vw, 520px); max-height:90vh; overflow:auto; background:rgba(20,20,25,0.95); border:1px solid rgba(255,255,255,0.12); border-radius:14px; padding:14px; color:#fff; font-family: Inter, system-ui, -apple-system, Arial, sans-serif;">
            <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:8px;">
                <h3 style="margin:0; font-size:16px;">Roster</h3>
                <button class="control-btn" id="close-roster-modal">‚úï</button>
            </div>
            <div id="roster-list" style="display:flex; flex-direction:column; gap:8px;"></div>
        </div>
    </div>
    <div id="info-overlay">Tap on objects to play music and see effects.</div>
    <button id="toggle-controls-btn">|||</button>
    <div id="controls-panel">
        <select id="scale-select" class="control-btn" style="width: auto; padding: 0 5px;">
            <option value="major">C Maj</option>
            <option value="minor">C Min</option>
            <option value="pentatonic">Penta</option>
            <option value="chromatic">Chroma</option>
        </select>
        <!-- Mode Select simplified for Angelus Novus concept -->
        <select id="mode-select" class="control-btn" style="width: auto; padding: 0 5px;">
            <option value="interactive">Interactive</option>
            <option value="sequencer">Sequencer (Plat Triggers)</option>
        </select>
        <div style="display:flex; gap:6px;">
            <button id="toggle-choir-layer-btn" class="control-btn" title="Also harmonize with choir">Choir</button>
            <button id="toggle-sequencer-layer-btn" class="control-btn" title="Add tap to spinning sequence">Seq+</button>
        </div>
        <button id="mic-btn" class="control-btn" title="Record mic to selected cone, or all by default">üéôÔ∏è</button>
        <button id="load-sound-btn" class="control-btn" title="Load a default example sound">üîó</button>
        <button id="clear-audio-btn" class="control-btn">üßπ</button>
        <button id="toggle-drone-btn" class="control-btn">‚ô©</button>
        <button id="toggle-names-btn" class="control-btn">Abc</button>
        <div style="display:flex; gap:6px; flex-wrap: wrap; align-items:center;">
            <!-- Play/Pause logic handled by turntable rotation directly -->
            <button id="reset-sim-btn" class="control-btn" title="Clear Spinning Sequence">‚ü≤</button>
            <select id="control-orientation" class="control-btn" style="width:auto; padding: 0 6px;">
                <option value="camera">Controls: Camera</option>
                <option value="plate">Controls: Plate</option>
            </select>
            <button id="reverse-drag-btn" class="control-btn" title="Reverse plate drag direction">‚ÜîÔ∏é</button>
        </div>
        <div style="display:flex; gap:6px; flex-wrap:wrap; align-items:center;">
            <button id="select-sample-file-btn" class="control-btn" title="Select audio file (assigns to selected cone; none selected = global)">Select (Cone/All)</button>
            <button id="apply-sample-load-btn" class="control-btn" title="Load sample to the selected cone or to all cones if none selected" disabled>Load Sample</button>
            <input id="hidden-sample-file-input" type="file" accept="audio/*" style="display:none;" />
        </div>
        <div style="display:flex; gap:6px; flex-wrap:wrap;">
            <button id="open-sample-manager-btn" class="control-btn" style="display:none;">Samples</button> <!-- Sample manager simplified/removed -->
            <button id="open-roster-btn" class="control-btn" style="display:none;">Roster</button> <!-- Roster modal unused -->
            <button id="toggle-center-lights-btn" class="control-btn" title="Toggle Center Lights">‚òÄÔ∏é</button>
        </div>
        <button id="help-btn" class="control-btn">?</button>
        <button id="arm-audio-btn" class="control-btn" title="Tap to enable audio">Tap ‚ñ∂Ô∏é</button>
        <div class="slider-group">
            <label for="rotation-speed"><span id="rotation-speed-label">Spin/Tempo</span></label>
            <input id="rotation-speed" type="range" min="-0.05" max="0.05" step="0.001" value="0" />
        </div>
        <div class="slider-group">
            <label for="reverb-level">Reverb</label>
            <input id="reverb-level" type="range" min="0" max="1" step="0.01" value="0.35" />
        </div>
        <div class="slider-group">
            <label for="choir-density">Choir</label>
            <input id="choir-density" type="range" min="0" max="3" step="1" value="3" />
        </div>
        <div class="slider-group" id="sampler-status" style="justify-content: space-between; width: 100%;">
            <label>Selected: <span id="selected-figure-label">none</span></label>
            <span style="color:#bbb; font-size:12px;">Sample: <span id="sample-status-label">none</span></span>
        </div>
        <div class="slider-group">
            <label>Plat FX: <span id="plat-fx-label">0</span></label>
            <input id="plat-fx-depth" type="range" min="0" max="1" step="0.01" value="0.5" />
        </div>
    </div>
    
    <!-- Sample Manager Modal (kept but unused in this version) -->
    <div id="sample-modal" style="position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:300;">
        <div style="position:absolute; inset:0; background:rgba(0,0,0,0.6);" id="sample-modal-bg"></div>
        <div style="position:relative; width:min(92vw, 420px); background:rgba(20,20,25,0.9); border:1px solid rgba(255,255,255,0.12); border-radius:14px; padding:14px; color:#fff; font-family: Inter, system-ui, -apple-system, Arial, sans-serif;">
            <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:8px;">
                <h3 style="margin:0; font-size:16px;">Sample Manager</h3>
                <button class="control-btn" id="close-sample-modal">‚úï</button>
            </div>
            <div style="font-size:12px; color:#bbb; margin-bottom:8px;">Target: <span id="sample-modal-target">none (global)</span></div>
            <div style="display:flex; flex-direction:column; gap:10px;">
                <div>
                    <label style="display:block; font-size:12px; margin-bottom:4px;">Load from URL</label>
                    <div style="display:flex; gap:6px;">
                        <input id="sample-url-input" type="url" placeholder="https://example.com/sound.wav" style="flex:1; padding:8px; border-radius:10px; border:1px solid rgba(255,255,255,0.12); background:rgba(255,255,255,0.06); color:#fff;" />
                        <button class="control-btn" id="load-url-btn">Load</button>
                    </div>
                </div>
                <div>
                    <label style="display:block; font-size:12px; margin-bottom:4px;">Upload File</label>
                    <input id="sample-file-input" type="file" accept="audio/*" style="width:100%;" />
                </div>
                <div style="display:flex; gap:6px; flex-wrap:wrap;">
                    <button class="control-btn" id="record-in-modal">üéôÔ∏è Rec</button>
                    <button class="control-btn" id="clear-selected-sample">üßπ Clear</button>
                </div>
            </div>
        </div>
    </div>

    <div id="help-screen">
        <h2>Angelus Novus: Spinning Sound Synth</h2>
        <ul>
            <li><b>The Plat (Turntable)</b>: Use <i>Spin/Tempo</i> to rotate the scene. This rotation drives the sequencer. Gesture-based rotation also adds to the spin.
            </li>
            <li><b>Play</b>: Tap figures to play their note. Drag a figure to shape sound (relative to the plat):
                <ul>
                    <li><b>Vertical</b>: pitch (y up = higher).</li>
                    <li><b>Horizontal</b>: stereo pan (left/right).</li>
                    <li><b>Depth</b>: filter brightness (forward/back).</li>
                </ul>
            </li>
            <li><b>Sequencer (Plat Triggers)</b>: In "Sequencer" mode, objects on the spinning plat trigger sounds as they pass the fixed <b>Angel's Gaze</b> line. Enable <i>Seq+</i> to add tapped objects to this spinning sequence. The plat's spin *is* the tempo.
            </li>
            <li><b>Angel's Gaze</b>: The glowing vertical line. Objects passing it trigger. Objects that have just passed briefly glow, representing the "past" or "wreckage" of history.
            </li>
            <li><b>Connections</b>:
                <ul>
                    <li><span style="color:#8a2be2;">Purple arcs</span> = harmonic relationships (interval strength).</li>
                    <li><span style="color:#44e5ff;">Cyan lines</span> = sequencer step playback (plat trigger).</li>
                    <li><span style="color:#ffb347;">Amber lines</span> = sample playback.</li>
                </ul>
            </li>
            <li><b>Choir</b>: Enable <i>Choir</i> to add automatic harmony on each tap or plat trigger.</li>
            <li><b>Fires (Cones) Hold Sound</b>: Click a fire to select it. Use <b>Select (Cone/All)</b> ‚Üí <b>Load Sample</b> to assign a sound to that fire. If no fire is selected, the sample becomes the <i>global</i> sound for all fires. Use üéôÔ∏è to record to all fires by default or to the selected fire.</li>
            <li><b>Scales</b>: Choose Maj/Min/Penta/Chroma. The drone (‚ô©) follows the root.</li>
            <li><b>Plat FX</b>: The overall speed of the spinning plat affects a master filter, creating a "spinning sound synth" effect.</li>
            <li>Tap this screen to close.</li>
        </ul>
    </div>

    <script>
        // --- Audio Context Setup and Constants ---
        let audioContext;
        let masterGain;
        let masterCompressor;
        let masterFilter; // New master filter for turntable effects
        let mediaRecorder;
        let recordedChunks = [];
        let droneOscillator;
        let echoDelay, echoGain;
        let recordedAudioBuffer = null;
        let reverbConvolver, reverbGain;
        let pendingSampleFile = null; // for two-step loader (Select -> Load)
        
        const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

        function initAudio() {
            if (audioContext) return;
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            masterGain = audioContext.createGain();
            masterGain.gain.setValueAtTime(0.7, audioContext.currentTime);

            // Setup Echo + Simple Reverb (generated impulse) and gentle compressor
            echoDelay = audioContext.createDelay(2.0); // Max delay of 2 seconds
            echoGain = audioContext.createGain();
            
            echoDelay.delayTime.setValueAtTime(0.3, audioContext.currentTime); // Echo time
            echoGain.gain.setValueAtTime(0.5, audioContext.currentTime); // Echo feedback amount
            
            // Simple reverb using generated exponential-decay impulse
            function createImpulse(ctx, seconds = 2.5, decay = 3.0) {
                const rate = ctx.sampleRate;
                const length = rate * seconds;
                const impulse = ctx.createBuffer(2, length, rate);
                for (let ch = 0; ch < 2; ch++) {
                    const channelData = impulse.getChannelData(ch);
                    for (let i = 0; i < length; i++) {
                        channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
                    }
                }
                return impulse;
            }
            reverbConvolver = audioContext.createConvolver();
            reverbConvolver.buffer = createImpulse(audioContext, 2.8, 3.5);
            reverbGain = audioContext.createGain();
            reverbGain.gain.setValueAtTime(0.35, audioContext.currentTime);
            reverbConvolver.connect(reverbGain);

            masterCompressor = audioContext.createDynamicsCompressor();
            masterCompressor.threshold.setValueAtTime(-18, audioContext.currentTime);
            masterCompressor.knee.setValueAtTime(24, audioContext.currentTime);
            masterCompressor.ratio.setValueAtTime(3, audioContext.currentTime);
            masterCompressor.attack.setValueAtTime(0.01, audioContext.currentTime);
            masterCompressor.release.setValueAtTime(0.25, audioContext.currentTime);

            masterFilter = audioContext.createBiquadFilter(); // New master filter
            masterFilter.type = 'lowpass';
            masterFilter.frequency.setValueAtTime(20000, audioContext.currentTime); // Start open

            // Master routing
            masterGain.connect(masterCompressor);
            masterCompressor.connect(masterFilter); // Connect master filter here
            masterFilter.connect(audioContext.destination);

            masterGain.connect(echoDelay);
            echoDelay.connect(echoGain);
            echoGain.connect(masterGain);
            reverbGain.connect(masterGain);
        }
        
        const scales = {
            major: [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88],
            minor: [261.63, 293.66, 311.13, 349.23, 392.00, 415.30, 466.16],
            pentatonic: [261.63, 293.66, 329.63, 392.00, 440.00],
            chromatic: [261.63, 277.18, 293.66, 311.13, 329.63, 349.23, 369.99, 392.00, 415.30, 440.00, 466.16, 493.88]
        };
        
        let currentScaleName = 'major';
        let currentScale = scales[currentScaleName];
        
        // --- Three.js Scene Setup ---
        let scene, camera, renderer;
        let turntableGroup;
        let backboardGroup; // Will be static
        let musicalObjects = [];
        let connections = [];
        let raycaster;
        let pointer;
        let showNoteNames = false;
        
        let draggableObjects = [];
        let isDragging = false;
        let activeObject = null;
        const dragPlane = new THREE.Plane();
        const dragOffset = new THREE.Vector3();
        let rotationSpeed = 0.0; // base spin from slider
        let turntableAngularVelocity = 0.0; // gesture-driven velocity
        let isRotDragging = false;
        let lastRotX = 0;
        let lastRotTime = 0;
        const whammyRangeSemitones = 7; // +/- semitones when dragging

        // --- Angelus Novus / Sequencer specific state ---
        let currentMode = 'interactive'; // 'interactive' or 'sequencer'
        let enableChoirLayer = false;
        let enableSequencerLayer = false; // "Add to sequence" toggle
        let sequencer = []; // Stores musicalObjects
        let sequencerNextObjectIndex = 0;
        let lastTriggeredAngle = 0; // Turntable's rotation at last trigger
        let sequencerReadLine; // The "Angel's Gaze"
        let playheadLaser, playheadLaserTarget, playheadBeam; // Laser downlight
        let platFxDepth = 0.5; // Depth of turntable effect on master filter

        let lastSelectedFigure = null;
        // Live preview synths while dragging (whammy)
        const previewNodes = new Map(); // id -> {osc, panner, filter, gain, overtones:[], ensemble:[]}
        let centerSpots = [];
        let centerBeams = [];
        let centerCones = [];
        let controlOrientation = 'plate'; // Default to plate-relative for "spinning sound synth" feel
        let dragReverseSign = -1; // default for natural feel
        let choirDensity = 3; // 0..3 voices
        
        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x0a001a, 10, 100);
            
            const vw = (window.visualViewport ? Math.floor(window.visualViewport.width) : window.innerWidth);
            const vh = (window.visualViewport ? Math.floor(window.visualViewport.height) : window.innerHeight);
            camera = new THREE.PerspectiveCamera(75, vw / vh, 0.1, 1000);
            camera.position.set(0, 5, 15);
            camera.lookAt(0, 4, 0); // Always look at the center of the turntable
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: 'high-performance' });
            renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
            renderer.setSize(vw, vh);
            renderer.setClearColor(0x0a001a, 0.8);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);
            
            raycaster = new THREE.Raycaster();
            pointer = new THREE.Vector2();

            turntableGroup = new THREE.Group();
            scene.add(turntableGroup);

            // backboardGroup will be static now, not following camera
            backboardGroup = new THREE.Group();
            backboardGroup.position.set(0, 6, -10); // Fixed position
            scene.add(backboardGroup);

            setupLighting();
            createClassroom();
            createMusicalObjects();
            createCenterConesWithLights();
            setupEventListeners();
            addNoteLabels();
            
            addResizeHandlers();
            // Safety: if initial size is zero (mobile toolbar transition), re-measure next tick
            if (renderer.domElement.clientWidth === 0 || renderer.domElement.clientHeight === 0) {
                setTimeout(() => {
                    const vw = (window.visualViewport ? Math.floor(window.visualViewport.width) : window.innerWidth);
                    const vh = (window.visualViewport ? Math.floor(window.visualViewport.height) : window.innerHeight);
                    camera.aspect = vw / vh;
                    camera.updateProjectionMatrix();
                    renderer.setSize(vw, vh);
                }, 50);
            }
            animate();
        }

        function addResizeHandlers() {
            function onResize() {
                const vw = (window.visualViewport ? Math.floor(window.visualViewport.width) : window.innerWidth);
                const vh = (window.visualViewport ? Math.floor(window.visualViewport.height) : window.innerHeight);
                camera.aspect = vw / vh;
                camera.updateProjectionMatrix();
                renderer.setSize(vw, vh);
                renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
            }
            window.addEventListener('resize', onResize, { passive: true });
            window.addEventListener('orientationchange', onResize, { passive: true });
            if (window.visualViewport) {
                window.visualViewport.addEventListener('resize', onResize, { passive: true });
            }
        }
        
        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0x2d004d, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0x4a007f, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            for (let i = 0; i < 3; i++) {
                const light = new THREE.PointLight(0x8a2be2, 0.8, 10);
                light.position.set(-8 + i * 8, 8, 0);
                scene.add(light);
                
                const lampGeometry = new THREE.ConeGeometry(0.8, 1.5, 8);
                const lampMaterial = new THREE.MeshLambertMaterial({ color: 0x1a0033 });
                const lamp = new THREE.Mesh(lampGeometry, lampMaterial);
                lamp.position.copy(light.position);
                lamp.position.y -= 1;
                scene.add(lamp);
            }
        }
        
        function createClassroom() {
            const floorGeometry = new THREE.PlaneGeometry(30, 30);
            const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x2a0a38, transparent: true, opacity: 0.8 });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            turntableGroup.add(floor);
            
            const gridHelper = new THREE.GridHelper(30, 30, 0x4a007f, 0x4a007f);
            gridHelper.material.transparent = true;
            gridHelper.material.opacity = 0.3;
            turntableGroup.add(gridHelper);
            
            const wallGeometry = new THREE.PlaneGeometry(20, 12);
            const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x22223a });
            const wall = new THREE.Mesh(wallGeometry, wallMaterial);
            wall.position.set(0, 6, -10);
            backboardGroup.add(wall); // Backboard is now static
            
            // Add a minimal disc to suggest a rotating plate
            const discGeom = new THREE.CylinderGeometry(16, 16, 0.2, 64);
            const discMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1f, roughness: 0.8, metalness: 0.05 });
            const disc = new THREE.Mesh(discGeom, discMat);
            disc.position.set(0, 0.1, 0);
            disc.receiveShadow = true;
            turntableGroup.add(disc);

            // Sequencer "Angel's Gaze" (Read Line)
            const readLineGeom = new THREE.PlaneGeometry(0.1, 10); // Thin, tall plane
            const readLineMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.2, blending: THREE.AdditiveBlending });
            sequencerReadLine = new THREE.Mesh(readLineGeom, readLineMat);
            sequencerReadLine.position.set(6, 5, 0); // Position it fixed in scene space
            sequencerReadLine.rotation.y = Math.PI / 2; // Make it a vertical line
            scene.add(sequencerReadLine);
            
            // Add a subtle glow to the read line
            const glowGeom = new THREE.CylinderGeometry(0.2, 0.2, 12, 16, 1, true);
            const glowMat = new THREE.MeshBasicMaterial({ color: 0x8a2be2, transparent: true, opacity: 0.15, depthWrite: false, blending: THREE.AdditiveBlending });
            const glow = new THREE.Mesh(glowGeom, glowMat);
            glow.rotation.x = Math.PI / 2;
            glow.position.set(0, 0, 0);
            sequencerReadLine.add(glow); // Attach glow to the line

            // Laser downlight and volumetric beam from the playhead
            playheadLaser = new THREE.SpotLight(0xb8c7ff, 2.2, 30, Math.PI / 10, 0.5, 1.6);
            playheadLaser.position.set(sequencerReadLine.position.x, 12, 0);
            playheadLaserTarget = new THREE.Object3D();
            playheadLaserTarget.position.set(sequencerReadLine.position.x, 0, 0);
            scene.add(playheadLaserTarget);
            playheadLaser.target = playheadLaserTarget;
            scene.add(playheadLaser);

            const beamGeom = new THREE.CylinderGeometry(0.32, 0.6, 12, 32, 1, true);
            const beamMat = new THREE.MeshBasicMaterial({ color: 0xb8c7ff, transparent: true, opacity: 0.12, depthWrite: false, blending: THREE.AdditiveBlending });
            playheadBeam = new THREE.Mesh(beamGeom, beamMat);
            playheadBeam.position.set(sequencerReadLine.position.x, 6, 0);
            playheadBeam.rotation.x = Math.PI; // open end down
            scene.add(playheadBeam);
        }

        function createCenterConesWithLights() {
            const conePositions = [-2.5, 0, 2.5];
            conePositions.forEach((x, idx) => {
                // Fire bowl (cone base)
                const coneGeom = new THREE.ConeGeometry(0.9, 0.8, 20);
                const coneMat = new THREE.MeshStandardMaterial({ color: 0x3a2a1a, metalness: 0.1, roughness: 0.9 });
                const cone = new THREE.Mesh(coneGeom, coneMat);
                cone.position.set(x, 0.4, 0);
                cone.rotation.x = Math.PI; // bowl-up look
                cone.castShadow = true;
                cone.receiveShadow = true;
                cone.userData = { id: `cone-${idx}`, type: 'cone', audioBuffer: null, lastTrigger: 0, currentAngularPosition: getObjectAngularPosition(cone) };
                turntableGroup.add(cone);
                musicalObjects.push(cone);
                centerCones.push(cone);

                // Warm spotlight as fire light
                const spot = new THREE.SpotLight(0xffa756, 1.6, 18, Math.PI / 3, 0.9, 1.8);
                spot.position.set(x, 5.8, 0);
                spot.castShadow = true;
                const target = new THREE.Object3D();
                target.position.set(x, 0.6, 0);
                scene.add(target);
                spot.target = target;
                scene.add(spot);
                centerSpots.push(spot);

                // Volumetric warm beam
                const beamGeom = new THREE.ConeGeometry(2.8, 5.4, 24, 1, true);
                const beamMat = new THREE.MeshBasicMaterial({ color: 0xff7b2c, transparent: true, opacity: 0.16, depthWrite: false, blending: THREE.AdditiveBlending });
                const beam = new THREE.Mesh(beamGeom, beamMat);
                beam.position.set(x, 3.2, 0);
                beam.rotation.x = Math.PI; // open end downward
                turntableGroup.add(beam);
                centerBeams.push(beam);

                // Simple flame sprite using cone-like emissive mesh
                const flameGeom = new THREE.ConeGeometry(0.35, 0.9, 16);
                const flameMat = new THREE.MeshBasicMaterial({ color: 0xffb347, transparent: true, opacity: 0.9, depthWrite: false, blending: THREE.AdditiveBlending });
                const flame = new THREE.Mesh(flameGeom, flameMat);
                flame.position.set(x, 0.9, 0);
                turntableGroup.add(flame);
                // Attach for flicker reference
                cone.userData.flame = flame;
            });
        }
        
        function createMusicalObjects() {
            const figurePositions = [
                [-8, 1, 5], [-4, 1, 8], [0, 1, 8], [4, 1, 8], [8, 1, 5],
                [-8, 1, 0], [8, 1, 0],
                [-8, 1, -5], [-4, 1, -5], [4, 1, -5], [8, 1, -5]
            ];
            
            figurePositions.forEach((pos, index) => {
                const figure = createHumanFigure();
                figure.position.set(...pos);
                figure.userData = { 
                    id: `figure-${index}`,
                    type: 'figure', 
                    noteIndex: index % currentScale.length,
                    originalPosition: new THREE.Vector3(...pos),
                    isActive: false,
                    isDraggable: true,
                    audioBuffer: null,
                    currentAngularPosition: getObjectAngularPosition(figure),
                    lastTrigger: 0
                };
                turntableGroup.add(figure);
                musicalObjects.push(figure);
                draggableObjects.push(figure);
            });
            
            // Notes are now just figures/cones as sound sources
            // Removed createMusicalNote and associated array
        }
        
        function createHumanFigure() {
            const group = new THREE.Group();
            
            const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.4, 1.2, 8);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x6a0dad });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            group.add(body);
            
            const headGeometry = new THREE.SphereGeometry(0.25, 8, 8);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0x6a0dad });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 0.85;
            head.castShadow = true;
            group.add(head);
            
            const armGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.8, 6);
            const leftArm = new THREE.Mesh(armGeometry, bodyMaterial);
            leftArm.position.set(-0.4, 0.2, 0);
            leftArm.rotation.z = 0.3;
            leftArm.castShadow = true;
            group.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, bodyMaterial);
            rightArm.position.set(0.4, 0.2, 0);
            rightArm.rotation.z = -0.3;
            rightArm.castShadow = true;
            group.add(rightArm);
            
            return group;
        }
        
        // Helper to get object's angular position relative to turntable center
        function getObjectAngularPosition(object) {
            const worldPos = object.getWorldPosition(new THREE.Vector3());
            const localPos = turntableGroup.worldToLocal(worldPos);
            return Math.atan2(localPos.z, localPos.x); // Angle in radians
        }

        // --- Event Listeners and UI Logic ---
        function setupEventListeners() {
            let pressTimer = null;
            let pressStartPos = null;
            // Disable long-press behavior to avoid accidental Sample Manager popups
            const enableLongPressSamples = false; // Kept for future reference but disabled
            // Resolve a mesh hit back to its interactive owner (figure/note/cone)
            function resolveClickable(obj) {
                let cur = obj;
                while (cur && (!cur.userData || !cur.userData.type) && cur.parent) {
                    cur = cur.parent;
                }
                return cur || obj;
            }

            function onPointerDown(event) {
                initAudio();
                if (audioContext && audioContext.state !== 'running' && typeof audioContext.resume === 'function') {
                    audioContext.resume();
                }
                const rect = renderer.domElement.getBoundingClientRect();
                const cx = (event.clientX - rect.left) / rect.width;
                const cy = (event.clientY - rect.top) / rect.height;
                pointer.x = cx * 2 - 1;
                pointer.y = -(cy * 2 - 1);
                
                raycaster.setFromCamera(pointer, camera);
                const intersects = raycaster.intersectObjects(musicalObjects, true);
                
                if (intersects.length > 0) {
                    const clickedObject = resolveClickable(intersects[0].object);
                    handleObjectClick(clickedObject);

                    // Dragging logic
                    if (clickedObject.userData.isDraggable) {
                        isDragging = true;
                        activeObject = clickedObject;
                        const intersectionPoint = intersects[0].point.clone();
                        // Anchor drag plane to plate (world Y-up), through the object's world Y
                        const worldY = activeObject.getWorldPosition(new THREE.Vector3()).y;
                        dragPlane.set(new THREE.Vector3(0, 1, 0), -worldY);
                        // Compute offset in parent-local space so mapping stays stable as the plate spins
                        const parent = turntableGroup;
                        const localIntersect = parent.worldToLocal(intersectionPoint.clone());
                        dragOffset.copy(activeObject.position.clone().sub(localIntersect));
                        // Start preview synth for real-time whammy
                        startPreviewForObject(activeObject);
                    }
                } else {
                    // Begin turntable drag
                    isRotDragging = true;
                    lastRotX = event.clientX;
                    lastRotTime = performance.now();
                    ensureRAF();
                }
            }

            function onPointerMove(event) {
                if (!isDragging || !activeObject) return;
                const rect = renderer.domElement.getBoundingClientRect();
                const cx = (event.clientX - rect.left) / rect.width;
                const cy = (event.clientY - rect.top) / rect.height;
                pointer.x = cx * 2 - 1;
                pointer.y = -(cy * 2 - 1);

                raycaster.setFromCamera(pointer, camera);
                const newPosition = new THREE.Vector3();
                if (!raycaster.ray.intersectPlane(dragPlane, newPosition)) return;

                // Convert intersection to parent-local, apply local offset, then clamp in local space
                const parent = turntableGroup;
                const newLocal = parent.worldToLocal(newPosition.clone());
                newLocal.add(dragOffset);
                // Keep within bounds on the flat plate (local space)
                newLocal.x = Math.max(-10, Math.min(10, newLocal.x));
                newLocal.y = activeObject.position.y; // Keep Y unless modifier used below
                newLocal.z = Math.max(-10, Math.min(10, newLocal.z));
                // Push back to world
                activeObject.position.copy(parent.localToWorld(newLocal));
                // Alt/Shift or middle-button drag: allow vertical (Y) movement as whammy height
                const isMiddle = (event.buttons & 4) === 4;
                if (event.altKey || event.shiftKey || isMiddle) {
                    const dy = (typeof event.movementY === 'number' ? event.movementY : 0);
                    // Natural mapping: drag up -> higher Y
                    activeObject.position.y = THREE.MathUtils.clamp(activeObject.position.y - dy * 0.01, 0, 8);
                }

                // Update whammy pitch in real time (preview synth params)
                updateWhammyForObject(activeObject);
                updatePreviewForObject(activeObject);

                // Cancel long-press if moved significantly (if enabled)
                if (pressStartPos && (Math.abs(event.clientX - pressStartPos.x) > 6 || Math.abs(event.clientY - pressStartPos.y) > 6)) {
                    clearTimeout(pressTimer);
                }
            }

            function onPointerUp(event) {
                // End drag for figures
                isDragging = false;
                if (activeObject) {
                    stopWhammyForObject(activeObject);
                    // Update angular position if it moved significantly
                    activeObject.userData.currentAngularPosition = getObjectAngularPosition(activeObject);
                }
                activeObject = null;

                // End turntable drag and compute inertia
                if (isRotDragging) {
                    const now = performance.now();
                    const dx = event && event.clientX != null ? (event.clientX - lastRotX) : 0;
                    const dt = Math.max(1, now - lastRotTime);
                    // Map pixels per ms to angular velocity
                    const velocity = dragReverseSign * (dx / dt) * 0.01;
                    turntableAngularVelocity = velocity;
                    isRotDragging = false;
                }
                clearTimeout(pressTimer);
            }
            
            renderer.domElement.addEventListener('pointerdown', onPointerDown);
            renderer.domElement.addEventListener('pointermove', (e) => {
                // update inertial dragging if active
                if (isRotDragging) {
                    const now = performance.now();
                    const dx = e.clientX - lastRotX;
                    turntableGroup.rotation.y += dragReverseSign * dx * 0.003;
                    lastRotX = e.clientX;
                    lastRotTime = now;
                }
                onPointerMove(e);
            });
            renderer.domElement.addEventListener('pointerup', onPointerUp);
            renderer.domElement.addEventListener('pointerleave', onPointerUp);

            // Touch fallbacks for mobile engines that prefer TouchEvents over PointerEvents
            function touchPoint(ev) {
                const t = ev.touches && ev.touches[0] ? ev.touches[0] : (ev.changedTouches && ev.changedTouches[0] ? ev.changedTouches[0] : null);
                return t;
            }
            renderer.domElement.addEventListener('touchstart', (ev) => {
                const t = touchPoint(ev); if (!t) return;
                ev.preventDefault();
                // Minimal shim with clientX/Y so our handlers work
                onPointerDown({ clientX: t.clientX, clientY: t.clientY, altKey: false, shiftKey: false, buttons: 1 });
                // Keep ownership during drag
                if (renderer.domElement.setPointerCapture && t.identifier != null) {
                    try { renderer.domElement.setPointerCapture(t.identifier); } catch {}
                }
            }, { passive: false });
            renderer.domElement.addEventListener('touchmove', (ev) => {
                const t = touchPoint(ev); if (!t) return;
                ev.preventDefault();
                onPointerMove({ clientX: t.clientX, clientY: t.clientY, movementY: 0, altKey: false, shiftKey: false, buttons: 1 });
            }, { passive: false });
            renderer.domElement.addEventListener('touchend', (ev) => {
                const t = touchPoint(ev); // may be null on some browsers
                ev.preventDefault();
                onPointerUp({ clientX: t ? t.clientX : lastRotX, buttons: 0 });
            }, { passive: false });

            window.addEventListener('resize', onWindowResize);

            const toggleControlsBtn = document.getElementById('toggle-controls-btn');
            const controlsPanel = document.getElementById('controls-panel');
            toggleControlsBtn.addEventListener('click', () => {
                controlsPanel.classList.toggle('active');
            });

            const scaleSelect = document.getElementById('scale-select');
            scaleSelect.addEventListener('change', (e) => {
                currentScaleName = e.target.value;
                currentScale = scales[currentScaleName];
                if (droneOscillator) {
                    droneOscillator.frequency.setValueAtTime(currentScale[0] / 2, audioContext.currentTime);
                }
            });

            // Center lights toggle
            const lightsBtn = document.getElementById('toggle-center-lights-btn');
            let lightsOn = true;
            const setLights = (on) => {
                centerSpots.forEach(s => s.intensity = on ? 2.0 : 0.0);
                centerBeams.forEach(b => b.visible = on);
                lightsOn = on;
                lightsBtn.classList.toggle('active', on);
            };
            lightsBtn.addEventListener('click', () => setLights(!lightsOn));

            // Orientation + Reverse Drag
            const orientationSelect = document.getElementById('control-orientation');
            orientationSelect.addEventListener('change', (e) => {
                controlOrientation = e.target.value; // 'camera' or 'plate'
            });
            const reverseDragBtn = document.getElementById('reverse-drag-btn');
            reverseDragBtn.addEventListener('click', () => {
                dragReverseSign *= -1;
                reverseDragBtn.classList.toggle('active', dragReverseSign === 1);
            });

            // Choir + Sequencer layer toggles
            const choirBtn = document.getElementById('toggle-choir-layer-btn');
            const seqLayerBtn = document.getElementById('toggle-sequencer-layer-btn');
            choirBtn.addEventListener('click', () => {
                enableChoirLayer = !enableChoirLayer;
                choirBtn.classList.toggle('active', enableChoirLayer);
            });
            seqLayerBtn.addEventListener('click', () => {
                enableSequencerLayer = !enableSequencerLayer;
                seqLayerBtn.classList.toggle('active', enableSequencerLayer);
            });

            const micBtn = document.getElementById('mic-btn');
            micBtn.addEventListener('click', toggleAudioRecording);

            const loadSoundBtn = document.getElementById('load-sound-btn');
            loadSoundBtn.addEventListener('click', () => {
                // Example: load a pre-recorded sound from a data URL
                const audioDataUrl = "data:audio/wav;base64,UklGRtUAAABXQVZFZm10IBAAAAABAAEARKwAAE66AAECAEAGTAAAZGF0YXUAAAD0L0A9J0E0B0c9P0I5OEdDPy5APzFBPll8V0JASz02QT58VlFAVEhBV0I6NlFBTExBVkM6PkBCTUM1MkE4S0lCRj40Rjh8VEFDO0U7SjY0V0hDSU1ETkdHS0tISk02QU9CQj5ETUlFQDczOTw4UkFDOTM1OTI4OEw4NEs2OEU4M0k5MDk4MTI3ODg0OTM2MTI5NjY4NzY1MjI4NzU5ODc0NzgzNzQ4MjU5MjE4MTIzOTM5NzI4NDEzMzQ5NjE0NzMzMTQ3OTY4NzE3MTkxMTM5Njk3OTY4MTAyNjk3MzA5MTI4Mzc4OTU1MzQ4NjM4MDY0NzI4NDM0NDc5NTQxNTM3NzQ1NzkzNTE3NTcwNjY3Mzk4MTMwNTEwMjc4OTU4NDQ3ODY3NTcwNjUzNDI4NTM2NDIyMzYwNDgyMzg3MzUxMTM4MjczNjkxMDIxNTczNjY0ODk2NTAxNDUzNDM1MjY1Nzc4MTYzNDMzMjIxOTExOTgzMTI3OTcwNjg4MTY1NDU2ODUzNzIxOTYxMTMzMTk4NTYzNjU4ODg1MzM1NjgwNTczNzA0ODc0NDY4NTcxOTcyNjE0ODExNDY1NjM2OTk2OTg3MzUzODU3MjQ2OTI5Nzg0NzY4MDUxNzk0OTY2NDE2NzE5OTMxNDYwNTI1NjUzOTExNjI1MjUzOTM5NDc2NTMwMTEzNzIwNjk2MzM2ODQ4MzM2MzEyMTUzMTI2MzE5NzY2MjQ3MjYxNzQ3Mjg1MjQwMzQ4NDQwMzc5NTE5MTIyMTI5NDQ3NzMwNzgyOTU2MDM2MjEyNTUyMjgzNjgyNzYyOTc1MjE3NDExODIzNzMxMTE0MTY4NDgyNDI0NTE4MzgxNTIwNDkxMzE3MzI0MTU0MTcwODMwNDk0NDI1NjQ2MzgyNzI0Nzk2MjU2NzU0MzU3Nzg0MDU3Mzc0NjI2MjM2NzE0NzQ2NTkxMTg0OTQxMjE1NjU3NjE3NjY5NjQzMTI3NzcxODc0MzY3ODc3NTYxNzUwNzE2OTU2MTUwNzE4Njc1NTExNzUwODIyOTMzNjY2OTI5ODU0MTA2MzkwMTQ3Mjc1MTExNDU3NDQyNzY2NDAzNjk5NTY0MTU0OTczNzY2Nzk3MzU4NTg5ODgxOTYyOTg5NzU2NzI5NjA3NzcxMTY5NzUyNjIzMzU4ODYzMTExMjI1MTAyMTc1NDgzNjkxOTk0NDY1MTEzMTg4MzE1MzE5MzY1MTgxNzM4ODYzMzQxNzU4MTAzNzY0NDQyMjUyNzI1NDIyNzYzMTA3NDg1MDM4NzcxOTQzNjI3MDQwMjM3MjQ0Mzg0Njc5MjQ5ODQ3NTY3NzgyNjUzNDY0MjYxODMyNTQ0OTQzNjM4ODIxNjA1NDkxNTMxODYxNTc2ODY2MDIzODQ1MjMwMTAzNDI0MjE4NzIzNDEyODgzMDYyMzM0MTkzMjEwMjA1NDc1MzI2OTQ4NjIzNDE5NzY3NDExODYyMTMyNzI0NDI3NTk1MTUwNTI2NjY0NzY4OTk3NTE0NzcyOTk0NTcwMzMxNjIwMzE3NTQ2NTk1NDUxNTM4MTA5NzEwNTQxOTc2NjQzNTg1NjEzNTY1NDM0OTg0ODA0NzU1MjgzMjk2ODMyMDMyOTMwNjQyMjIwNTM5MTA1MzkxMDQyODY2NDgzMDMyNzQ0ODQ3OTEwODgyNTA5OTkxNzA2OTc3OTM3NjU5NDM5NjU3MzQ2Nzc5OTk4ODIyNDg0OTY5MDcwNzk3MjcwNTMyMDc2OTQ0MjMwNDc0NTg3Mzg5NDU4MzkxMDc4MTQ1ODg4NTI2NDIyMjUxOTY4NjY2MzQ5OTc4NTU1ODg4NzMxNjk0NzU2NzU0NDQ4MjU4MzYyMTY0MTA4ODgwNTgyNjMwODY5MjI1Nzc1NTI5OTkxNTU2NzI5ODMwNjY5OTEzNjU5NTc4MzYzMjk2ODE0NTg5NzUyMjQ5ODIxODg0MjI3NjMxMzY5MjM2NDMyMTcxMjUwMzgxNzU0NDU0MzY1MjE5NTA3NzU2NjE3NjIxNDk1NzEyMTczMDMwNjgzMTI4NDgzMjY0ODIzMzE5MzA5OTM0Nzc3MzExNTEzNDg5NzA2NzM1NDE2NzMwOTI0NzU5MzM4NDYyMTUzMTIyMjc2MTU0NzgzNDMyOTQxNzQyNzI0NDQ0ODkzMTI1MjYyMTU0ODQwMzM5MTc0MDUxODU0ODgzNjY1MTI5NTY2NTk3NzU0MzU3MDU2OTkzODUxMTg2NjQyNDgyODQ1NTczNjQ0NTY1MTcxMTMzNzg0NzcyNzY1NDgzMjgzNjIxNzY0OTQ5MTIwNjA1Nzg3MTQ3NjE3NjYwNzU2MzMxNjgzMTk3MDIxMzM3NTMzMDM2MTEwMzY0MTg1MzI1MTU2Mzk4MDUyMTM2NTI3MzYwMzQxMjk0MjY3NjE5MjIyODY5NTYzNjM5NDgxMjM0MjUzNDU0MTE1OTQ4NDgyODMyNjQ3NzE1NDk5MDM2ODIxMjUwMjk5NzIzMjY1MjE5OTg4OTg4MTA0MTg0Nzk1NzY1NjI0NTg1Mzc4ODY3MzIwMzI5MjQxMzcyNTc3NDg3NDgxNjM5NDcxOTUzMTQ5MTAyNDkzMDUwMjk3MDI0NjEwMDQyMDUwMTEzNTcyMTIyNTU3MDQxNTM0NTEwODQwNTQxMDI3MzEzNzI5NzEzODU1MDQxOTg1MDY5MzgwOTEzNzUwMjEyNjQ1MzI1NDczODE1NzM1MzY0Nzc1MTQ1MTA2MDY2NjU3NjU0MjQwMzcyOTQ5ODE1MDM1MjUzNzUxNDg5MDgyNDg2NDU4MTE3NDk2OTU1OTI2Nzc3NjY2MTA4MDc4ODg0NDY5MzM3MjIzOTIzNDU5OTI3NjkxNDYwNDM0NzI0MTk2ODgwMzg2MTQzMjUyMzExNzI4OTc4MDQ2NTY4NTgxOTc4MzM0MTIzMTE1MDgyNTg5MzA2MjE2MDgwNzY4ODU3MDU3OTY3NjEyODUxMTE2MjgyOTg4NjYwMDc1MzUzMzc4NzkwNjU4NDQ3NzM0ODQ0ODQ3Mjc1NTExOTk0MDMwNDkxMDY3NDY1MjgxMzExOTIxODIyMDU5Mjc2OTUyMDI5NzQ1NjU3NDQyNzY1OTkyODY3MzIxNzYyNjgyMDM4NDQxNzIxMzc4MTQxMjQ5MjU5MzE5NTk4NDg5MDQ5NzYxNjEzMjYyOTI4MjY2ODExMzY4Mzc4OTYyNzM4MTMyNzM4OTk3ODU4NTQ2OTI5ODQ3Mjg1MzkzMjI1MTExNzU1NDkxODA5NDMzMTMyMDI4ODcwNDk2MzMyNDI4MTMyNTIzNDY4MjU1NTA1MzI4NjE3NTE0NzIyNTI0NDcxMDc2NjMxNjUxNzk4MzIzNTMyNDE3NjQxOTEzMTIzNTA3NzE0NzIxMDU3MTAzNzI5OTQxNDY4NTY2MDc4ODk3Njc2NTYyNzE4ODg4NzMxNjk4OTUxODE2NTYzMTI4NTk1MzM2ODQ2OTg1MDgwNDUzOTQyODg4MDk0NTEyNDUxMTg2NzE5OTczMTQxNTQ1NTA3MTcyOTYyOTUzNzcyMTA2MjUzNzc3OTIyOTU0MDI4NjIzNjUyNDMzMzIxNjgyMjI3NzUwNDI4MzM3MjIyMjczNTc4NTgxMzU1NDc4NDQ2NDcyNjk0MTgyNjUyNzEzNDQ1MzQwODQ4MTE2NTk0OTI3MzQ2ODU1OTMyNTM4NjI3MzM5NzI0NDgzODg2Mzg2MzY4MzYzOTg3NTU4NDcyOTc1NDM5Mjk0MzY2NTU4NTIzMTQ0NjMyMTk3NTAxNTk0MzkzMzUwMzUwMDY3ODE4OTUxNDI3NDUyNDEyMjQ0NTA3MDIwNzcwOTkzODUwNDQ1NzMzODEwOTI5NTM5NTc1Njk2MzY3NTk3MDM2OTg0ODg4NzQ2Nzc5OTMzOTMyMzIyNDY2NzUwNTQxODUyNjA5NjI2MjM4OTYyMzk3ODY5MjEwMDQ5MzU4ODcxMjkwODk3ODg2OTgyODQyNDkxNzk4NjkwMjUwMTA4NDIzOTY3MTc4NTMyOTM0Nzc0NTg2NTc0NTAxMTYzODczNjMwOTk1OTc1ODIwNzIyNTUyMDQwNDM1MDUwNTYzNzgyMjU4MTg5NDcxMTM4ODg3NzI3NjE4MzMwNjc0Mzc2NDkzNTA2MTM2NzIyMTQxNDI0ODY2ODU0NjI2MzU2MDYwMzg0MTQ0MTM2NTc2MTE4OTg0ODYyNDMxNzQxMTI2MzEyNzU0MjYzOTYyOTQ0MjA1NzU1MjI5NzYwODQyMDkzNzM3ODU3NjE1NTE3NTI5NzY0MjMxNDU4ODYyOTI4NTgxNTY0NDc2NzUxNjc5NTY3Mjk3MTc1NTExMDc4NTMwNDc4OTk3MTk2NTI1MDgyOTQ4MzY0MzkxMjgyNDY5NDExNzY4OTE3NjQ5MjEyMTE1NzQ3MzQwMjQzNzY3NDQxNzQzNjk2MzA2NzI2MDI5NDExNzM5Njc2Mjk2NzM4NTMyNTM3MzQxNDUxOTIzNDMxMTIwMDQ1NzU4MjYwOTM3NjgzODE4NDg3OTcyNjQxNDU1OTg3MzM0MjU5NDIwOTk0MzExNjYxNTg3NDg2MTYxNTE1Njg4MjI0NDcxNTE5NTI2OTQ5NjcyNTE3MDMzNTAxNDI5Mzk0NTMzODU3MjI1NTUzNTM2ODg1MzQzMjQyNTI4NTc2NjQzMzM3MTgyODkyNzQ3MTk1ODUzNTAzODk4OTc3MTc5NDI5NjY0NTgzNDI0NjEwMzYzMjk2MzY5MzQ3MjcyOTI3MjA3NDExODE2NDMyMTM0MDYxNTgzODQzNjE1MzE2NDk2ODQ4MjkwNTM0NTA3ODIzNzEyMTgzMzQ0NjgxMjUwNzU0MzIyMTg0ODIyNzcxMjI1NDk0MTkyMjk1NzcyMjQwNDI4MzM3NzU1MDQxNzQ3NzI4MzkxMTQxNzI1OTQ2MzQ3NTg0MjI3MzUyODUzMzk5MTUwNjYzNzU5ODc0NDY4NTE3MjQxNzExOTkzODg4ODAzMTM0MDM2NjQyOTQ1NzkzNzUyNDg2ODE3ODUwMTAyNTczMzMwMTkzOTQ1MjA4MzM1MDQ2NzU4MTE0NTU0NDUyMjk2MzEzNzEzMjk2NDcyMDYzNjQ4NzkwNDgzMjczMTk5MTAzNjQ2NDk2MzY4ODY2MTc2OTg3OTcyNjkxNDE0MTgyNTk3OTQyMzY3NTkzMTE1MTgyNzg4NjUzNzQ2MjQ3MTY3MjU4Njk2MjA1OTg5NjY0MzQ2ODU1OTg3MzU4MzQ0NjE2ODg4NjM2MzU1OTYzODYyMjQ1MzI5NzA3NTYzMjI3NDcyMzI5ODQ2Njk0MzExNjkwMzM0MjE4NTY5NTA3MTU5NTA3NzE4NTYzODQ1NDc2NzA3NjQ1NTQzOTcwNTIyNzY3NTI2MjEzMzMxMTAzODk3Njc2MzY4NDQ2Njc5Njg3Mjg1MjY1NzkwNTA2OTQxMjY4MzI1MzQ1NDQzOTk1MTg0NzkwMjQzNjIzOTc3MDU1MzI0NzUzMDU1NzYxNTIzMjgwMDQzMzY4NjcwMzI5NDQ3Mjg0MDYzNjY0MzgzMjUxNDY3NTUzMDk0ODU0NzY2NjMxNTQ5NTQ5MjQ2MzQ3NTU3NzQ1Nzk3OTI1MzMzMTk2Mzk3NjQxMTUyNDgyODYzNzM3MTUwMjQwNjE5MDM2ODczNDM0MDM5NDk0MzMyNzk3NDQ5Nzc0MTU1MDQ0Mzk4ODg2MzgxMzA2Mjk4MjE4Mjc3MTQ1ODY3MzM0NjU3NDQyNDE3NjcxNjQ5MjQ1Nzk5Nzc0NzIzNzQ2OTYwNTEwNTk2NTM3MTYzMjcyMjk0OTY4Mzc4OTMxNzM5MTcwODQ2NzM4NTQzNzQ5MzcxOTI5OTM4OTU4MTAzNzI2MDI5NjEzMjM3MjcyODY2NTU2MTY1NjQwNjExNDUxMzgwMjI2MjM2NTYxNzk3NjgxNTMyNzE1Nzc5MDI2NjY5MzIxNjM5OTg4OTg4Njg4NzY5NDM4NDI3MTgxMTUyMjEwNzUxNTY0NDM4MjU4MzYzMTA4NzUxMDY3Mzk4MTMwMTM4OTY2NzgxNzA3NzQ1OTg1ODE3MDExNDk1OTczNzg5ODYxNjUyNDQ2MzA4OTQ1MTM1NjQyMzgyMTczNTc2ODg1Nzc1MTk0Mzk3NTA0NzE2NjM5ODg2NjY0NzI4NDMxOTcyMzE5ODYwNzg4MTI2NDIwOTk0MTI4OTUyMTQwNDI1NzI2NDMyNjQ2MDQ1NjE3NTE0MTM4NTM3NzI3ODQ4MjcxNDQ0OTUwNzQ1MzY1MzA1Njk2NDU2NzE5OTI1MjM4OTE1MDQ1MTIxNDI3NTIyMzU3NDg0NDczNDg0NDI1NjU0OTcyMzIwMjY4NDMxMjY3MDgwNjY2MTUwNjEyODQ1NjczNTA4MTE3ODQ0OTI3MDY1MzIyOTk4NzEyOTQ2NDM4NTcxODU5ODUxMzgyOTUzMTQwNDc0NzgyMTk0MTYzNDExNTE5MjM3NjU0MjMyMTU0NTE2MTQzMjY3NDI1NjM3MDQwMjM0OTI1ODc2NzY5ODc5NDIxNzU0ODY2Njg0ODg0NzQ0MzI1NjY0MTA4ODQ3ODU3NjE3NjY0Mzc3OTgyNzUyMTgyMTU1NjgzNjkwNTE5MjczOTcyMTA1Mjk5Mzg0MTQxODExMjIwNDc2NDg1NjM1OTIyNDk2NDgyNzcxODg0NzUwNjg5NTM4MTU3NTA1MzI5MDIzODE0NzU2NzY1NTc1MTg1NTM5NDQzNzM4MTg4NTY2ODYzMTAwNzU3MTM5NTQ2NTk3MTk4NTc4MjIxMjYzNDQwNzM0ODg3MDM0ODcwNjQ2MTQ4NTA3NzU2OTkyNzY5MDQzMTQ5MTQ3MzI4NDYyMzE3NDY2NjE3Nzk5ODg3NTU4MzM3MjQ4OTg2ODUwODMyOTIzNTcyNzQzODgwNzM2MTY2NTQ4NDkwMjQ4MzMxNzc4MjM3NjM5MjUzODE1MjU2NjM3MjE2OTg5MjUxNzY3ODE2NDIxNjgyOTY3OTMyMDM1MzQxOTU3MTU0OTgxNzU1NzYzMTQ1NTg1NTYzNTA4NzEzNDc5Mzg3NzE0NzU5NTY1NDQxMTYwOTYxNTIzNzc1MjQzNTQ2NzE5NzIyNDYyMjUwNjE3NDg5MTQ0OTUxMjk2MTc5MzcwMjMxMzcyNDc4NTU1MzExNDY3MjE0NDMwNTcyMzg4MzM0MTIyMDM5NDg4Nzc1MzMxMjE3NjMyMTIyMDk0NTY0ODU0NDM3NTk5NDIxMDExODAyMjY4NDY2ODQ2NDY3MzMyNDkzNDg0MTA4NDI0NDc1OTcyNzY1Mjk4Mjg5MTQyNDMxNDQ1NTI3NTU1MzY5NDcxMzc4NzkwNTQxNjc5NDgyMTE4MzI5NzMwMzQyMjQxNzM5NTk2NTQ3ODk1MjM4NjQ3MDczMTMxNTExMDI4Njc0NDg2Mjc5OTcyMDM3NzUyMTY1MzExNjg1Njc1NTYwNzM5MjA1MTY1NDExNDk2MjY3MTg1MTA4ODMxMDY3ODg4MTA5Nzg2MTA2NTEyMjM0MTMzNTYxMDY4OTk3Nzc5ODQ4OTMwNzE2NzA4MzQ1MzM1NjUwMTcyOTc5NTI5OTkxNTQwMjIxNDMzNDc0MTM5ODUwMTg3OTIwNDkwNjg0OTU5NTI3MDc4ODg5MTU4ODY4Mjk1ODg1MTEwOTM1MDk3OTg3MzE5MzY1MTgyNjkzNjQwNjIxNjk1OTg4NDEyMjE3NTgxMTI2Mjg3MDQ3NTEwODc1NTY4OTgzNTY1MDUxOTU0NTI3MjE0MjQ4MzI1NjEzNzUyNjI2MTQ3NTc1NTQxMTYzNzU4NTEyMTY1MTI2MzE3NTY3MDkzNDUyNjYxMjMxMTAyMzYxMjkzMzcxMzcxMjI4NTI2ODUyOTY4NjIxNjk5Mzk2NzMzMTYxMDI1Njg2NTk0NjU1OTY0NzA4ODg0MzU0NzE2Nzc2ODk3NTkxNDU1MzQ3OTE4OTM0MzI5MTI0ODEwNzk0MTUwMjkxODY2NDk3NzYyMTU0ODExOTI0ODU3OTc3NDQ4NzcxMTk0ODE0OTg4NDQxNzQzNTYzMjI0MDcwMDc2MjI0NzI0MTM0ODU4NDc2MzA3NzI0OTY0MTYyNjk4NTMwNTIzNjk4NjIwNzQ3NTc2NTY2ODk4ODU5NzM5MzY5Mzc4NzA3NDg5ODc3MjY3MjQwMDc4MDY0NzQ2NjExNDY2NTc1NDMwMTQyMDY0MDk4MTUzMTY3NjA4MTU3MDUwNzMzMDk1ODkyODExMDgwNzQ1NzEwMTM4Mjg3ODU2NDU4NTIwNjE1OTgyNzM3NzA4Mzg2MzY1ODUxMDk5MTgzMzU0NTkxNTk2MDMwNzUzMjU1ODk5OTgwMjYzOTEwMDQyMDU2MDM3MzcwOTQ1Njg3ODU4NjgzMDYzNTg1MTk2NzU5NTE5NTEwNDQ0NTM0NTA3ODk2Mjk2NzI0NzExNTIwNjY1OTY2NjEyMzUxMDc3MTM4NTM3MTgyNDMwOTc2MDU2Njc4MjIyNTM3MTMzNjUyNzc1ODYzMzI5NzU5OTEwODQ4NDQzNjExMTE1NTg4NjMxMTUwMTU5NTI2OTc1NDY4MDExNzM1ODE1NDk0MTQ4MTc0MDUxODc3MDI0MjQ0NzA0NDM2OTk2OTU4MTAzNjQ0MjkxNTU4NjA0MTIyNTAzOTg1NjEzNzY0MzM4OTY4NTU4NDQ2OTgxNTUxNDQxNzQzMjgxODQ2NjU4ODg1MzU5NzI1NDQ5MzM3MTMzODYyNzY0NDYwNzA0ODc4MjUxMTIwNDI3NTkxOTYxMTY2ODEyMTIyNTM0NjMzNjgzNDI4NTM2NDIyNzkzNzU5MjI0NzEyMjMxNTg5MTk2NDAzMTE2NTk0NDI1NDQxNDk3NTE2NzcyNTg2NDIyMzY1OTQ2MzQ4MTk2NDcwMzUxNDg5MDc4MTUzMTQ3MjczMzE4MzY3NzQ2NjY1MjYzMjUwNDY3NTYzMTg4OTE2ODYwNDM3NjQ4MzUzMjY2NTQzNzIyOTc3MDI4NDQyMjUyNjIxOTMzMzI1NTQyNTE4MzUwMjY4NjgzMTIxNjkzNjkwMDY0NTQ3ODk4OTc5OTk3MTk4NzMxNjk4MzM5NDU3NzcyODg2Mzk4NzY1NjY1OTExODY0MTQxMjIwNTQ4NDg2NDQyNTk3NDg4OTcyODE5OTI5NjU4MTE3ODQ0NDU0NDU0MzY1MzUwMTQwNTI2NjcwNTI0NDY1Mzc0NDYwMzcxMjkzMzI1ODYyMzUzMDMxNDQ0NjY2OTEwMzIyNjM3NjE2NTg1MTY3NzQ3NzUxNDYzMzUxMDIzODQ1MjY1Nzg2ODIyMTMwODcxMTYzNjE5NDgyNzA4MjQ1NTcwNDUxODEyNjM0NDU0MDk4MTI5MjY4NjYzNjU0NjMxODg5OTQ0OTgzMTYwMjY2MTg2MzU2MDMwODUyNDQ2MTA2NTgxODg0MTc0OTY4Mzk0NzMwNzU2NzY1NDg1NDUzOTUzODEyMzU5MjMyMjkwODU2OTI1MjQ0OTQ4MjM4MTA5MDQ1NTMzNzIyNTM2NjM5NDMyOTczNjk1MzM0MDkxNDIyOTE2Njc0Nzg0Mzc1ODMwNTAwNDU2NTg4ODQ4MTEzMjcxMDM2MDgyNDc2MzcwMTE1MDIyMjIwNDkzOTY4MjY3NDkwMzk2MTk5ODE1MTM0MjIzMzcxODY5ODU2MzY2NDYwOTg4NDQ1NzMzNzg1MTEwMTU3NDgzMjcyNzY4NDk0MTQwOTk1NDExMzE3ODQ0NzUyMzA5ODcxODczNjY1OTcxODk4OTEwMzI4NjA3MzgxOTg5Mzc4ODQ2NjE5Mjc4NjYwMTU1OTk1Nzg0Njk1NzQ0MTc1NjY5MzM2MzE5NzEwNDk5NDY4NzE0NTU5NTIzMTk5MTU5OTUwMDY4MTAyNjk3MzA4NzcwOTk3MjcwOTc4NjYxOTY3Njk2ODg4MTA5MDY5MDU1NDg3NDU5NTM5MjM5NDc3NDQ2NTM1MDgwNzc3MTI0NTk2ODUzNjMyNTY4NDMxMjA3MjgwMjU1MzQzODUyNDUzNTA1NTA2MTc3MzEzOTY0Nzg3MjQ1NjM3NDI4MTA2NzQ2NDgzNTIyMTY1NDI0NjE2Mjc4NTIxNjkzMjM5MzcxODQ2MjEzMzI5MTgzNjExODkzNzQ3MTcwMjM3MDI2NDgyMjY2NzYyMjI0NTI0Nzk2MjQzMjY3OTg1NTk3ODMxMjU1MjYyMTU3MTgyODQxNTQ0Nzk3Mzk4MTMwNzQ1NDEzOTQ4NjczMjg0NDY0MTk0MjU0MzcxMjM0NjUxNjAzODQ5NTU0NTMyODU5MTk4NzM5NDM0Nzg1NTk3MTE3MjYyOTI4NDc4NjkxMTE0NTUzNjY0MzM0ODMyNTgzNDY3MzM2MTQyMDY0MDYzNzQ5MjQ5ODk0NDY1MzA1MzcxNDc2Nzg2MzI4MzUxMDM5NTIyNzY5MzM2NjgyODc4NjAzMTcxOTQ5NjE1NjMyMzU1OTkzMjI4MjQ1NzYzNTMzNTUxOTgzNTkzNjc2MDM3NzM3OTMyMTQ5MzI5ODc1NDY0MjgxOTc2NjU5NDkzODkzMzcyMTM4NTM3MjQ0NTA3ODIxMzgyMTY0Nzg0MDQ3MjI2MzEyNzY4MDY1NjU5OTM0MTcyNzU2NjE3OTE0MTEyODkxOTE3ODY4NTUzMDkzNTU2ODU2NjM4MzcxMTYzNTkxMzA0Nzc3MTc5NDAzMTQzMjYyNTk0NjE3Mjg0MTE1NTk3MzYyNzQ2Nzc5OTY4MzIyNDg0NTgxMzY4MzYzOTgzNDMyOTcyMDIyNDQ5Nzk2MzY3Mjk3MTY5MTYzMTU2NDAzOTgyNjIxMTE1MDY3NzM0NzUyNzQ2NzIxOTczNDUyNjgyOTUwNzY2OTg2NDg1NjE0NDYzMjM1MTI2NzY3ODAzODYyNzI1MTEyNDQxNDg5Mzk0NTIzMjY4NjEyODAzNTQ1MzYyMjk0MDQzMjI5NTM5MTg4NjE2MzM2ODY5OTI3NjkxMzIwOTM1NjA1MTI4NDI3NDMyNTc0OTMzMjkxMTU5NzYyNTc5MTQxODMzNjExNTQ3NTg2MDQ1NjM1NDczMjUyODUwMzcxMDU0ODIzOTc1MTYxNjQ1MzI1MzQyMjI3MjQ4MTQzOTY4MDc3NDUwNTY0MTE2NjU4MjIyNTM0ODEzNjM4NjI3MzY4MTEyMTY1MTIzMjg2MzcxMjY4MjI5NjQxMDMzMTIyNTMwMzc0Mjc5Njk1MzkwMTk4MjIyODMwOTI4MjA2Mjg5NzYzNjQ4NzUzNTQ5MjUzMDc2NzMyMTk0MTQ3NjMwNjMzNzUyNDM5Njk2MzIzNjE4NDMyNzU5MjM1NzM1OTcxNzM2MjgzMjYyMjQzMjMzNzE4NzY2NDgxODEyNzYzMDI1NDM1ODY0OTkxOTU0MzgyNzU0ODMxNDkzOTE0MDU1NTUxMTExMjExOTcxOTcxNzAzNDM5NTExMDIyNzgyOTk1ODEyODcyNDIzMjQ4MDc2NTI3MzYyNDk5NzUyMDYxOTk3MzY5NDcxNTgxMjc3NzI0MzI4NzMwODMyMzYxMDY4MTczNzMwNzk2NzY5MjgxMDcwMjY3MzQzMzgzNTExMDU5NTI5NDg3NDUzMzg1NDUzNTk1MTcxMTM1NTY4NjExNjM1Nzc3OTQ0NTQ5NjUxMjYyNDEzNjI2MDMwNDcyNzY2OTY1NTMxNTQwMzQxMTI2MTYzNDM5MjU2Njc3MzU5MjMyMTUwMzk5MTAxMDY0MTYyNzc1NTI5OTkxNTQwNTI5NDc2NTU1ODg4NTUzNzYyNDc3NzU5MDc0NDQyNjY5NjgxODYzNTc5NDMyMjQzMjU2NDM0MDc4NjkxMzA0NTE1MTU2NjY2NzM4NTMyMTg5Mzc0MjA3OTExMTY0MTY5NTgyMjMwMzM2Njg1NTQ4Mjk5Mzg0MDMzMjU2NjUxOTM0NjM2Mjc4MjUxODIwNzM0NzQ3MjE5Mzg3NzUxMDgwNDM2NjM4MzI4NjcxMTI1OTYyODAyNDY0MjY0Njg0MzE5MzY1MTUxNzgyMjU4MTcwNzE0NzEzNDQ1NDc2MzY5MzU2MDQyODg2NzA4ODg0NDcyOTE4MTc0OTY3NDU4NDMyMjg0NDM2OTk2Nzk1OTgzMDk5ODYxNzgzNzI3NzU1NjE1NjY5NzY2NDQ2MzU5NDgyMTE4MzEwNzYxMjUzMTU0ODQwMjQwMDIxMjg5OTk1NTQzMzI2NzY4NTMxNzI4NTk1MzM4ODU2ODc2NzY3NTI5NzY0MjkxNzMxMzg4NDgxNjI2MDk1NzgzMTcwOTc2MDU5NjIwOTQ5NTEwMDMwMzM4MTI4MTYzMzQxNzMyNTYxODU2MTE0MTk1NjY2NDAyODMzNzE1MjgxNTk2NDYwMzUxMDYwNDk3NjY3MjE3MDc1NTc4NDExODIzNDM2Mzc3NzE4NDcxMzM2MTEwMzQ2NzY4MzM0MTIyNzM3MTQ0MjI5ODUwNTI1NDcwNjk0NDUyMTc0MzkwMTMzNTk4NzYzNjcxNTI5MzYxNTI3MDU1NDcxMTY5NDU2NzE5Njk4OTUyMDc1NTM5NDg3MTEzMTE0MTIwNDQ4MzcyNzU5MzkxOTUwMTE0MTk3MTg5MTgzMzk3MTA0NDUzNzkwNDg5MDQ3NTE2NjE2NzI2ODE0NzkwNDEwNDQyNjEzMDc3OTY2MzU5NTg4ODQ2MjIyMzM5MzM3MjIwNjY1NjYzODg4Nzk5MjIzNTE4OTExMjkzOTczMjY4OTM0NDI4NzY0NDUzNDM1MjYyMTQ5NTMxMzgzNTMzNDU5MTMxODY2MTUzMjQwMzk1Mjg1MzkzNzY2MzIxNTI5Nzg4Nzg3MTE5ODU3ODk4NDQ0OTc3ODYyMjE4OTk3NTA2NjA1MTM1MTU5OTIyMzcxNTYwMzQ1MTk5MTk3MTExODIyMTA2Mjk2NzI4MzU4NzI1Nzg0Mzc2ODE3Mzg1MDM3NjcwMDc1NDU4ODcxNDczNjY3NjE5OTM2OTgzNDMxMDQyNjI0OTM4NTM3NjI3NDgzNzk3MjUzODc2NjYxNTE4MzU4ODY0MTAyMTM4ODg0NjI5Mjk0NzY3MzkwODY3NzIxNTA1MzU3MDcyOTM5NDc2NTY3NzU5ODYxMjUwNTc2ODQ1ODY4NzI3OTI4ODQ3MTM2NDMxMzM4NzE1NjgyMTI3MzIyMTMyMTA2NzIzODMwMzE2NzA3NTY4NzYxMTkxODExNTc4NjUzNjM5NTUxNDIyNDQ5NjkwNzc5NjE4MjgyNzE4OTkxNjM0NTYzODU2MTIxMTQ5MDcxOTQzNTY2ODE3OTM1OTM4OTU3MzM0NTEzNDg5Njk1OTM4MTM5MzA0OTQwNzMxMTI5NzI5MjY4NjE0MDc2ODE2NzIzNjk2MjcyNzI2NjA4Mjg2Mjg4OTg1NzQyMzU4OTg5OTgxMDMxOTkzMjg0MzIzOTE3MjEwNjYxNDc1NTY2OTI5NTg1MTc0MTM5ODgyNTE5NDcxNTc3NDQ0NjA2NDg3NTE1MTU0ODk1NzIyMjcwNzE3NTA2NjUxNzU0MzgyNzU4NjQ2NTA4NTIzNTAxNDY1Mzc0NDMwMTcxMzExODgzMDQ1ODc3NTY1NDg1MjYyNzcyNjQyMjM0MTQ5MzI3NTg2MDM3ODg1MjY2NDUzNjA3MzgxOTY3MzY1MzA1NzgxMjk1NTYxNzYxNjMyODQzMjY3MTU1MjI5NzY5ODc0NzMzNzcyNDYxNTM3NzI3ODQxNTc5Mzk0NTQ3NDMzNTI3MjIxMzIxMDcyNTk3NzI4OTEzMzQzMjQ2MjYyODQxMzEwNTc4NTE2NjM4MzE3OTI2NjkzNDIwMjM5NDc0NDg3MTg5NzkwNDM0NjQ1NDI4ODIxNzg1NTU2OTIzNzc1NzA3NTQ0MTQyMzA0OTM2NzU2Nzc1ODkyMTY5MzA3NDM3Njc5NjcxNTYzMTM0OTk3ODg2OTQ0OTYxMDQwODQ5NzMyODQ4NTA2MTU4MjYwMjczNjg2MzcyNzgxOTc3MzE3NDAzMjI5NTM5NTUzMzQ1NTA2MjExMjU5NDIwNjE5MDM1ODY5OTEzODMyMjgzMzYyNTA4MTIzMTM3NDExMjQwMTMxMjM2MTI4MTcwNDE2ODY5NTkzMTExNjUxMjcyOTY0Mjc4MjY1MTI2NzY3ODUyNjU3NzI3Nzc2NDI1MzM4ODQ2NDI3NDUyNzU3NDExMjk1MTUzNDE5NjUwNjU5NjMxNzI4Mzk5MTY3Njk4OTM2NTcyNTk3OTQyNjIwMzI5MjQxMzI5MDQ2Njk0MjE4MjMzMTc3Mzg3NjA3MzYwMzU2NzMxNzUwMzU4OTgyNjU1MjQ5NTI0OTE2OTcyNzQ3NDQ3MTAxODc0ODUyMTM5NDI3Mzk1NTk4MzE5MTc4MzE2MTYxOTM5NTI2MTIyNzYzMTQ1OTIyMDc2MjI0NzQ4NzkwMjM4NzM0ODc3NDU0MzUxMzY3NDU3MjIyNDgzNDU0MjQxMzYwODcxNjY0ODg1NzY2NDQ2NDcyNjg1NjQxMTA1MzkzNzY2MzcyMjI5MTI0ODEwNDY1NzUyMjMyOTIyNzQxNDUwMDU3ODk3MDc3OTY3NTQwNDQwMTMyNzEzNjY3OTEzMTQ5NzYxODUyMTI5MzE5NzY2NDEzMzQ5MzExNTkxMDgzNzM5NTIyNDg4NTU2MDMzMDI5Njk5MDU5MjY3MTcxNjk4MTY0NDY1NjM2MjYxNDMwNTA0NjUwNTYyODc2MjA1ODg5ODQ5MTQ4NDcwNTAyNzQ3NjQwNzUyMDExNjMzMjc0MTIzMDM2MDk3NDU4Njc1NDU3MDQ4MTA5MDk2OTU5MzYzNzUzNzYyODU2NzQ4MTY4NTQ2MTExMDk0NTEyNjI2ODcxMjgwOTg5OTU1NTUwMzYxMTEzMzQwMDkxNDQxNzIxMTU4NzcwMTczMjY4NzQ3MjE5MDQ4NDIyMjA1NTI0MDYyOTkyODIyMjk5NTI1NzY3MjgxOTE2MzI4MzYxNjc2NjU0MzU4MTQ1NzU4OTE0Mzk4MjY3NDY4NTcxMzU4NTM3MTgzMzU0NTg4MzUyMjE2NjI2NzMyMDQzMTY0Nzg3NjU2NzM3ODUxMDU2MTM3Mzg2NDE1NDMyODY5NzMzNDIzNzE5MDUyNDc2NDg5NjU4NjIwMjY1ODg4MTQ3ODc3MTg1MDIwMzY3NzQ4NTM5MjkxNzYzNDI1MDExNzQ2MzQ3OTUwNjEwMTY0Mzg4MjA2MjY5NTQ3NTM4MTU1NTUzNTM3ODMwNjQzMTQwMzExNjc0NjM4NjUwOTg3MDcyMzUxMjUzMjA1NTY0NzU3NTQ1MjY1Njc4NTQ0MzYzNjg4NTgzOTUwNDk4Nzk3MTg3MDc2OTU2MjMyNjE5MzM3MTkzNTU4OTE3MjU0OTg5OTg3ODU0MzI1Njc0NzgxMjk1MzE1MjQxNDM0NDk2NzU3MjYxMjkwODcyNTgyMzc2NzI0MjQ2NDg2MTY3NzMzNTUwMTU1NjE2MTU0MTQzMjk3MjgzMDU2NDgxOTQ4MTEzMjY1MjE0ODQ2MjkxNTUxMzU5NjgyNjI2NTUzNTA0NzgyOTU3MTU2ODk3NTc2NTUyOTcwMTY0MzIxNTA3MjM3ODk2Mjk5ODU5NzM2NjUwMTE0NTgzNDI2NjU3NjgyMzQzMzIzMDk0Mjc2NDYyNTg3NDM4ODYzMzg5NjQ5MzQ0MTczNzkzNDcxNTEyNjE2Mjc4OTI4OTU3MzY3MTYzNjk4NzQxOTUxNjUwMTg2NTg2NzIyMjYwNDI0NzY4OTU5MDQ3NTE1MDQxOTI2NjQ3OTY4MTA4MTcyMDM5NzUxNzM2OTk2OTg0Nzk1NDUxNjUzOTkzODY2MTI3Mzg1Mjk0NDk5NzMzNzU2NjE4NDQ3NzMwMjM1NTY0NTY2MTEwNjk1MTUyNDc0OTkxOTU3MTI0NTM4MTU3NDQyNzgzMzc2OTE5MjczMzYxNTI3MTA1NzA0NTE0MTgzOTU3MzMyMzc2MzY5MzU4ODQ4MTc0MjgzMzM3NjY3OTk5ODQ4MTE1MzA1Njk1Njg5NjczMDcwMzcxNTM1MTE0NjcxNzIzNDE4MDcwNTEzMjUzNzM5NzY4NTAzNDcxNjEyMDU0NDEzNjcyMzM2MzM4MTU2NjYwNDM1OTUzOTIzNTU1Mzk3NzE5MjU1NDQxNzA4NTAzMTM5NDI2NDQ1NTA0NjQ1MjkzMDIxMTY3NzQxOTI1OTMxNjQ0NzYwNzUxNjk1MTYzNDc4OTk1ODYxNzk4MjM3NjM5MzM2MzIyMDMyNjIyNTA5MTUyNzYzNjEzOTY3NDYwODE5NjA0NTcxNzU2ODg0MTc0MDU5MjYxNDgxMjMyMTA0MjU5NzU4NjE4NDUzNDYzMjEyMjM1NzI2MzkzNzI2ODkzNjU3ODU5Mjg3NDgzOTk2MDQxNTAzNTgyNTU3Mzg1MTUxNDQ4MzMwNDcyNDgxMTE0NjQ5NjUyMDI0MTY3NTUxNTg1NjgxNjQ0NjE5OTM0NTEyNjkwMTEwNzU2NTI3OTc4MjA0NTMzMjM0NzU4NjgxODQ5ODY5NDE4OTE1NTMzMTk5NTg0NTI0MDgwMjU4MDY5MjE1MTY2MzQ5MjQ2NzM1OTQ0MTM2NDUwNTA2OTQ1MDk2NzE5NjkxODUwNjU4NTkxMzk2MDQxMjg2OTQwMjU4OTMzMzIzOTUwODUzNDg5NzQ4NzYyMDU2MDc4OTc2MDMzMDI5MjUxMTc2MjY5NzY3NzQ0MzY0MjMzMTI0MzQ4OTg0NjEyMTU2Nzc1NDczMjA2NjkxNzU5MDYzMTUzNTM4NjcxMTI1MTk5Mjk2NDExODExNDcyMTY4Mzc1ODMwNTIwMDI5NDM5NzI4MTg4MzE2MTMyNDExNDM5OTMwNzk2NzIxMzkzNzkzMTU2MDU1MTc3ODU4MjUwMjU5ODUwOTU4MTk2Mzc1NjM3NDgxMTI2OTkzMzIzMTUyNTMyNzU4NjQxODc0ODUwODc4MjQ2MzQ0MDYwMzg0NTg3MTU1MzY3NzIzMzEzNDQzNTMwNjE2NTI5NjE0NzEwNzY2NzIxNzA1NzMxNzMzMDU2MzA1NjEzNzY3MTc5OTczNTEyOTk5ODQ5MTU0ODk1NzIyMjcwNzE1NTIyNDgyMDkzODY4NzQ3NTU4MzYyMTk2Mzg5MzE4NTE1NDYzODIyNDY2OTU3MzI1NjI4MjI1MTk1MDI4ODgwNTc5NDMyNzE4NzQ3NTA1Mzc3NzgxMjgwMjQ2NzI2Mjc2NzM2OTk1MDQ1MTkxMTE2NzcxMzE3MjUwNjQzMjMxMDY1ODg3NzI3ODQ2MTUyMTE1MTgyNjk2MjcyMDM1NjUwMDI0Mjc1NTExNDY5ODcxNTQwNDIzNDIxNzY3NzM0Mjk3OTI4MDIwNTc0NDIzNTU4OTE3MjEyODYyMDM5MTc0MDIxMDgzMzQ2NzI0NjEyNDI1Njg5NzQ4MjI5MTE0NDc2NzUzNTk1MTgxNzUzMzc1MTA5MzE3NTM2NjMxMDYzODYxODk0NzI0MzMyNjY1NTkxMzU3NTU3ODc2Mzg2MzU5MzI2MTI5ODcyNjExNjU0NTIzMDExMzg2Mzg1MjcyMjM4NzQ2MTc5MzcwMjMxMTIxOTY0NjExNjQ1MzIyMjMwODEwNjU4Mjg4MDM1OTE0OTI5MDgyMzI0MjY1MTk2ODIwMTM1NjUyNjU5MTkyMjU4MDUzNjQyNTgyNzE0Njg2ODg1MzM5MzI0OTc4MzUwMTE1OTQyMTMyMjk2NTE3MjQxNzM5MzUxNzYwNDczNzA5MTIzNzUwMzcxMzI4NjI5OTMwNTY2Mjc2MDcxMTQ5Njk5MDU4MTM5MTA1MTM4NTM3MDQ4Mzc1MTE3MzE3OTM5NjU0ODU3MjUwNTg4NzYzNzEzOTE3MzY3MTUxNzY5NDgyNzYyNTc2MjM0MzM0MDczNzM2ODQ2NDI3OTE4MjQyNzUxNjMxMTM4MTg0OTQ4NzM2NDcxMTUxOTE5NzM3NzMzMjc5OTY3NDI2MzcxMTY1MDgyNjY0NTE5NjY1MTk0OTU2MDQyODk5NjI3NDgzNjI0OTM1MTAzNDI3MzI1NTgzMTQ4NTQ5Mjk0NTgzMzM2MzU5NDY5MDM5OTY2MTU4MDkzMTg4NjkxMjc4NDc1MjEzMjE5NjEzNDQ3NjEzNjg4NDk1MTc4NTEyMTY1MTgyNTIyMTI3ODYwMzIyNzY2MTQxMjQxNjUzOTY5MjM2NzQ1OTYzNzEyNTQyNjQxMzQ4NjM4Njc3MzU4NzI1NjgyMzM3NTY5MTA2NTI1MDgyNzcwNTg0MzY3OTQ0MTAzNzQxMTk0MjEzMzU1NTQ0NTI2NTA5ODczNDIyNTYxMDI3MzUwNjc1MTk4MzY5NTM2NzY4NTYzNzc1NDM1NzQ3OTE4NTc1OTczOTMxNDY5MzM4NDc2NDMxMTMxNzg1MDU4MzcyNzU3MjY4MjQxODc2OTkxMTQyMzE0NzI0MTY2Mjg4OTg1NzQyNTUzMDUwODgyNzI5NjMxMTY3MDk0MDU4ODc1Nzg0Nzg5Mjc0MjYzNjA2MTE3MzMyNjIwOTMwMDc2NzQyMTc4ODYzMzQxNzMxMTY0OTg5MzQ1MTM0NTI0Njk4NzQxMzExNjExOTcwMTYzODIyOTM5NjU4NjM1MDI2NjU4MjgzNzUwMzc1NDQ2MTg1OTc2MTc1NjgzMTY4MzY5NzY3NDQ5ODYzMTE3NjE1Njk4NDc4ODg0NDUyMzIwNTMxOTc0MzcyNDgyNDY3ODQ3NjM4ODkxNTQ3NzUzMDQwNzI0OTMyMTUxMjYzNjEzNDM1OTQxOTY5MjE1Mzc0OTc4NzE4OTkxNjM0NTYzODk4ODQ4MTg0ODMxNjI2NjE3OTcwMzI3MDMwMzgyOTY1MTI5NjIyNTU5MjcxOTYxMzMzMzI0NDI2MjE2MDQ3MzQ1Mzc4MzE3MjQ4MzQyNDk5MjY3OTQ0MDQ2MTM3Mjk0MzI5MDk4NjIzODYzOTc5NTI5NDU0MTgyNTkxMDk5NDUxNTAyMzg4NzIxNTMwNzIzMzg5MDQ0NTg3MjU5MjU2ODQxOTU3NjgxNTkxNzM2MDUyNTY4NDQ3NzM0MTM0ODU2MTY1MzExNzQzNTA3MTU3Mzc5NjM5ODYyMjMyMTg5MDQ0NjgxMzQxNTYxMjY0NTU1NDkxODIzNDg0ODIxMjc1Mzc0MDYxOTk3MjU3ODUyNzk1MTQxNjI0MjcyODMzNDAzOTI4NDYzMTk3ODUyOTI2MzIwNTU4MTI3ODU3NjE5OTg4MzUzMDUyMzkzNDk4NDMyNjUyNzM2NDMyMTM2NzIzMzg5NDY0OTQzODgyMDcxNTYzODU2MTUwMTg0Mzc0MTMxNjczMTU3NjY5NjM0NzU2NzM4MTMyMTYyMTE3ODQxNTk2Mjk4Mjk2NjY2NzI2MTAzODY0MTY3OTczNDUwNDE3MDgyMjU3MTU1MzE5NDM1ODYzNzMwNjgzMTM1MTYxMTM1MTA2MDYzNjY1NDQxMTYxNjQ4MzU1OTEzMzU2NTQ5NTUzMzg2NTg1MTY3MDUxMzA5NzU2OTgzODc0MTE2NzcxOTQ3Nzk5ODg2OTk5MTIyMzE4NzA5NTA4NTY1MDUwNTU3MjQ2OTU3MzI3NjkwNDM3ODU1NTI5OTQ4MjMxMjgyODc4OTYyNzM4Nzg4OTUyNzQ2NzA3NTMxNjQ5MTczNjI2Njg1MDYzMjQ2NTQ2NjM2MTE1NjY0MDI3MDYzNjM1NTg2MjYzMDI3MTM3MzA5NjgxODYzNTc5Mjc1NDM2OTY3NDcxNzIxOTczNDMwMjk4NzgzNDY3MTczMzg0Mzg3NjU2MzcwMjY2OTM1MTg1MTY3NDEyOTQ4Mzg3MTU3MTAyODYzNTUxMzM4MzE4NDM5Nzk0NTU4OTU1OTg3MzIxMTAzNjI1MzUzODEzMTg3MjI0ODEwNDYyNTExODUyNzM0OTUxNDY0MDM3MzIxMjA5ODQzNjE1ODQ1Nzk5Nzc3NzM4NjI3MzQzMzI2NzY4NTYzMTk4MDcyNjY3MjY2NzYyMjI3NzA5ODIxNzc2MDUxMjc1Mjk0Mjc3NDgzNjI2MDExOTg2NzM2NzQyMjEzNzA2MzgxMzA2Mjk2NzM2NzI4MzYxNzk5MzY5MzU4ODU0MTIzNDY2OTU3NTM5NDQ2MjIyMTkxOTE5MTUwMTU0NzQxODY0OTQxMjIzMzk3NjI1OTU5NTg2NzMwMDYxNDExMzU5Mzg1NzM0MzM0ODIwMTk4MjU3MzgzMTIyMTMwNDczODg2ODc2NzY1OTI4Njg4NDk4MzQxMjM1MDM0Njg1ODY4NjY0MzIxMzkwNDI2NDQ5MDM1MTY0NzY4NDk2NDUyMzA3NzUzMTg5MDM5OTYxMjM4NDM3MjUyNzQzNjkzNTI1MjYxOTU0MjI2MDYwOTcyNjEwNzY2MTk5MjI5ODkxMTA2OTg3OTY1NTI5MTQ5Mjc4NjI3MTIzOTg4NDQxNzI1OTIzMzkzMTYxODgzOTg2MzgzNzE2OTU2MzMxNjY2MDU2OTYzNDEzODE5NjQ2NjM1OTMyNjIxNjk2NzYxNjczOTgzNjI1NjU3NzIwMjE5NDM1MjI4NTA3NzE4NDU2ODgzMTcxNjk4MTk0NjgyNjA2NjY0NzY1NjIzNjIyMzcyNzQ2NDkwMTI4NzYzODQwMzcyOTc1ODU4Mzg5NDY2MjI1MzcxNjE5ODc4OTE5NjEwNDUxNjMzNzY1OTcyMTc4NTEyMTY0MTE2MTc4MjE5NTk4MzU5MDc4NDMzMDcyMzUxMjU1NzYxMDI1OTk0ODUzOTMyNzg2MDk5NzI4MTg4NTM0MTY0NjI3NzQyODQxMzM1NTI1NzkwOTYzMjk4MjQ5NDIzNDc5OTY3NDgyODE4OTg4MjkxMTAwMDI2OTQ4NTQ5Mzc2NDIyNTUzOTY3MjA1ODg5ODIxMTMzNzI1MjIwNzY5NzY3NDExMzMyNDI2NzM1MDUwNTYxMzI1NzQzNjMzMTU4NTk5NTc4MzU3ODUzMzI4MzEzOTcwMzUxODQxODc2MjA1NzU1NjUxODQyOTU2MjA0OTg2ODgxNzMzMTM2MzIwNDE3NTYzODY0NzUwODQzNjM4ODc1NzM2Njk1NjQzODMzNTgyOTkxMTM5Njk2MzM4MTk5NTA2NjA2MTE1OTU1NjQyNjIzMDY3MTMwOTU0ODUxMjI5NjM3Nzk4NjA0MTIxNzU0MzA1NTU4MjE4MTEzMjY1NTY5NzYxNTU0MTg1MzgzNzY5NDgyMTQyOTU2NDUxNjk0NTE2MzU1OTI2MjU1NTg4NjE4NDcxOTUzMTQ5OTgzODExMTMyMTY5MjY0NTYxOTk3MzY1MzA1ODUwNzQ3NjA3MzYwMzgzNzQ4NzY2NDExNTEzOTcwMTUxOTkxODYzNjUyNDU0NTQ0MDcxMzI1NjA0MjQzNDUyNjYxMTcyMjkwMjUyODIyNTYxOTI2NjY0ODU2MzYxNTI3MzY4MTEwNjY4MTQxMjcyMDI2MTYxMjI1MTE4MjQzODUwODcxNjczNzY2Nzk3NDQ3MzA4NDYzODk1ODc1NTMyMTIzNTAwNjUzNzU1MDU3MjM2OTI3NjUyNzc1MzY4MTEyOTYwNTU5NjI1NjQ2MzgyMzM5NjUyMjEzNzQ0MTc1NDM5NTM5NTUzMzIzNjkwNTUwMjcwNjE1ODk3OTMzNDg4Mjg2MjgxMDM5MjQwMzcxMjc1MzEyNDQ5MDYzNzQ5NDI2NDYzNzExOTEyODE3NjM5MzI0NDY1MjgxNDU5NTI3NDI4ODQ5MzE0NzE2NjQ2MTY4NDc5MTU2MjI2MzE2NzEwNTcwMTg4Mzg3MjUxMTc2MjU3NDIzMTA2NTEzNzMxODQ5NzE1NzY4MDUxOTE3MTA3ODY5NTQwNjQ2MjU5NTM1Mjg5OTM4Mzk2Mzk3MjczNjI2MjM5MjI2NTY3NTk0MzY5Nzc1MjgxODQ0NDM4MzI4NjcxMTI1NDg4NzI3MTE4NzI1NzA1NTEwMjc4ODgxMjYyMzQ1NTE2MTQzMDc0NTc4OTg2ODUzODk0MDc3MjI1NTU1MzExOTk3MDkxNTUzMjExMjc4MzUwNzE3NTI5NzY0MjQzMzA0MTI2NjM5NDcxMzc4NzgwNDM5MzY0MDc1MjE4MjQ5MjU3NzU1MzgxOTY3Nzc0NTg2NTc0MzcyODE2NTE2MzE0NjM5ODkxOTc1MzkwMTIzMTY1NzM5Njc2NTg3ODY2NTUxMDc0MDUxNTY1MzQ2MTc5MzY5MzI3NTYxOTY3NDc2MTcwMzMzOTkyNjg2OTcwODkyNzA4MjU3MzMyMDgyNzA3NjE3MzE3MjQ4OTQyMjM0MTU0MTQyMDI5MDM0Njc3NzI4Mzg2MjA3MDMyNjQxNDU5MzkzMDI0MjQ0NDI5NDc2NTgzMzEyNTA3NDg1NDY5MDc3MzUxMzgyOTYzNjk0MDk0NjMzODg1MTQ4Mjk3OTQ0NTQ0OTk4MjUxMzI0MDI0NDM1Mjc2MTkzOTIzNDMyMjk4Mjk1NTg4NDc4MDU2NDcyNzcwMTEyODYyNzYyODE0MjYxNjkxMjIwNDIzODg1NjI4NTk1MzM0NzM4Mjc1NzU2MTk3Njg3MjU1MTA4MzcyMjE0NDQ5NzYwODQyOTgzNzk4NDUwOTU4OTc4MjY4MzExMDc5Njc4NzU3MjY1NzM3MjcxMDU3ODU4MjIzMzQ3NTg3MjExMTM1NzY3NzYxNTU0ODkzMjcxNTI4NzYzODQ4MjkwNTYxMzM3NTY2NjM2Mzk3MjM5OTQ2MzkwODA2MjgzMTU0NTMxNDQzNDM0NTA3ODc4NzgzOTkyNzY5MjU5ODAyNjMyNTMyOTc0MTQ2MzE5NzUyMzQ4NjM4OTMyMzk4NDY2ODQ1ODYyNTI5MTQ1OTc4MDUzNTk2Mjk1NDkzOTMxNjcyNDcwMjU0Njg0MzE4Nzg5NTAxMDI2MTQ3ODYxMjE1NzY4MjgzODIyNjU2Njk0NDQ1OTM2MzU4NjA0MTc1NjMwMzM4MTU1MzE5OTU5NTcyNzA5MjY5NTM2Mzc0NTI5NjIyMTY1NDExNDk5NjEwNDQ1ODY3MzI2MzI0OTQzODUyOTM2NzU0MzU3NjI1OTQwNDI1NzcwMTc0NzUxMjMxMDY1ODMxMzY2NzcyNDkyOTQ2NDM4MTM5MDU5MjY1MDU1MzI5MDIzMjI4MjkzNTcxMzYxNzI2MDY3OTEzMzg1MjMxNjI0NjEyNDI1NzExNzI2ODcyOTkxODc5MjM4MTM1Mzc0NDcwMTQ0NzU2NzM3MDY1MzQ1NTgyMDc2ODUxNzQxMTcyMzU5Mzg2NzQ4NDIyMjA3NzMyNzY3MjI2MjI3NzE0NTgyMjQ0NzIzMjY3MzUyNzI3MzkzOTI0Nzk2NzYxNzU5MjM0Nzk5MzMzMjUxNTQ4NDIwNjMxNzI5MTk1MDI5MDU2NDc2MDIxNTQxNzgzMjcyNTUzNTMxMDcwNjk0MjYzNDYyNzcwODQ3NTA1MzI4NjYzMTkzNjQ3NzQ3NzIyMTM3ODMwNjUxNzU1NzEzMTg1NzU1NDkwNTI1MjE2MjUzOTYxNTYzMTM3OTEwNjUzMjI2ODQ2OTcyNTI0NzI0MTk2NzU1MTE1NjY1NDc5NzIyODQzOTU4NTMxMTE4MjYzODUwMTc5NTA3NzE0NzcyMjU0MjY0NTU2NTcyOTk2NTYzNDEwNDYzOTg0MDY0MTUyODU1NjgyNzg2NzI3Njg3OTc1NjQwNDQzOTk3NzI1OTExOTkzMTI4NjU0NDk0Mjc4MjI0NDU1MTIzMzU5MjU4MTQyMjYwMjM1MTA2MDQ5NzY2NDk2NzcwNzcyODYyNTYzNzc4Mzg1Mjg3NDU0MzUxMzk3MzUwNDQ1MzM1NzA0MTU3MzIzNDY4MjU1MTQ2ODMyODExNjEyNDQ2NDM0NDc3NjUyMDc3ODUzNzMxNTA0NTE5NzI4NDM0Mjk3NzE4MzQ5MzM3MjQ0NTEyMDc0Nzk4NDIyNzE3NDM1NzQxNTM0NzYxMjQyNTEwOTM2MjU4MjI4NTA4MzIzMTAzNjMwNTM3MTYzNTIwNTEwNzg1MzU5NzcyMzY2Mzc5MzcwMTEzOTcyNTMyMTA4MTkzMjIyOTU1NDkxMDQwNzU3OTY5NjQzMzA5MTAyMTk0NjA5NDg4NjAzNzkxODg1NzE1MDMwOTg1MDExMzEwMTU3NjY2MTAxOTU5NDgyNjY4MDM0ODcwMDYzMDUwMzU4NzI1Njk5NTI0MjIyMTQ0NTY0MjI4NDI3MTYwNzI5MzYxNTI1MzY3NTcxMjk0NzY1ODQ3MzE2OTg2NDcyODc0OTcxMjQ2MTczMjk3NjkzODczODc3NDU1Njc1OTY5MTUyODE3NTIyNzU1MTcxMTE1MTgyNjk3MzA1MTc5Njg5NjYzMjIyNzY0ODU1NDEzOTEzOTM0NzE3MzkzNTk3MTM2NTI5NTIwMzc2ODU0NjQ4MzU4NDk3MDU4MzQ5MjM5NDQzNTMwOTgyNjIzOTUyMjMzNjcyMTg5NTc2MTQ0OTE2OTk1MzU5MDQ3NTE2NjUwNzE0NTExNzU0ODc4NjkxOTI5NzkzOTc2NTM4MTMxNDg3MDMyMDMwOTEzOTg2ODUwODcyMDk4NDM3MTI3MjcxNzUzNDkzMjk3MTI4ODAyMzI2NDYyNjk0NTEwODc0MjgxOTc1NTU1NjMyNjU5NTYzOTMxNTIzMTc5MjUzNTIxMTU2MzYwNjk0MjE4NTkxMDI2MDk4Mzg3MjcyODkyOTgxMzM5NzM3Nzk1NjkzNTgyMTQ5NTM4MTY1NDc2MDI1Mzk0MTE0MjEzOTQxMjY4NDMxNjk3MjA2Mjg5NzYzNzI2NDg5NjU4NjkwNjk3NDY3MjMzNDEzMzg5NTE0NzYyNTc5Mjk5NDMxNTI4NjQwMTAxNDkxODQ2Nzg5OTI1NDI3MzYwMzcwOTY2NTI3OTc4MjIzNzM3NzUzNzg3MTI3NTE2NTI3MTA1NDI4OTk3MTMyOTEzMzM5MjM5NTA1ODY1NTMzNTMxMDgwOTI5OTcyNzA5Mjk4MjE4MTA4ODg2MDU1MTIzNjMyMTE0MTk1NTg4NTY2NDcyNDY1NDIyNDk5NTkxOTg0NTI3NDI0NzgzNTcxMjMyOTYyNzkxMTkyNDU0MjU5NjIzMTk5MjI4NTk1MzIxMDMzNTAxNTc0MzE4MDUyNTYyMzUzNDU5MDM2NDU3NTE5Mjk1MTExOTgzNDYzNjg2NzM4NTYzOTM3NTY2MTcyNTU0NTY2MTM4NzA0MTMzNjQxMDkxMjIxMzY2MDMzMDI5NDM0NTMwNzU3MTA1MjM3OTEwNzQ2NTY4NTI2NDIwNjM5MjY3MTg1MDI3OTc4Nzc0NjQ4NDc1MzI4MTMyNTMyNDUxMDk3NjcwMzIzMzU4NjQ2Nzc0NTg2OTU0NTA4ODY1MzY1NDQxMDQ3ODc3NTg2NzIwMTI4NTQzMTI3MzU2NTQ5MzU4NzgzMzYyNjkxMTM0NjYzNDU0Mjg3Nzk0NDQxMzg5ODE2NDIyODY5MTgzMjMwNDE4OTU5MzQ1MTEwMjg1ODQ2MjI3NzcxODk2MzQ4MTc0MDIxMzEyNDcxNDkwNjU1Mzg5MjE1MTk3Mzg0MjM5NjI1NjU3NzI0OTQ3MzA2NjEyMDgwNzIzMjIyNzU2OTkyMjQ4NzQyNDIwNTMwMTUwMjU3NTUwOTMwMTU0ODE3MDQ1MTM4MTUwMzkwMTY5NDU5OTY3NDU4MjYwMjYwNjMzMzg5MjkwNDk2Mjk4MDU3NDM1OTQ0NTgyODcwNTc5NTEyMjI3Nzc2NDk0MTQwOTk5NzM0NjMyOTQ2MTgzNjExMzk1OTEyMTkzOTk1MzQ1MDI4Njk5MzQ2MDIzNzI1OTY5MTMyNjUxNTUxODIzNjI3MjU1MTA4OTkyODc1MzE1NTc4MjM2NzE1NDQ3OTc5MDU0ODkxMjgxNDU5MzgzNjIyODQwNDc5MDU5MjIyODk3Mjg4NzMzODE2NzU4ODk3MDM4MTcxMjExNDQ1NzA1MjE2MDY0NjcxNzg4NDcyNDkzNTc4MzU3NTg4MjQ2OTUwMjE3ODQwNjg1ODc3NTk0OTE3NDU5NTI5Njg3MjU1MTk3ODk2MTEzMTg4NzI4NjE5MTQ1MjUwNTg4NzYzNzEzOTU3NTg1MjU0NzI1Mjk3MDIyNTc2MjU3NDM3NTAzOTQzOTQ4NzM3MjM4MTYzNzE5ODg2MjgwODE3MzgzMTM2OTMyODg0NjExNTU2MjU5MTQyNDIzNTUzNTI5NjEwMzUxODQ1MzU5NzgzNjk2NzE4OTQ2MDYwOTIyNjExODQ2NTQzNzgyMDY4MjY2ODg2MjEzMjg4NzI4ODY5NTg3NTUzMDcxOTUyODk4ODQ4NjQ1MTI1NjQ1NTcwMTc3MTAwMzIwNDkzNDU1NzM0MDk1MjY5MTI5Nzg1Nzc3OTU2NzY4MDIwNTQ2MjA3MDM0MzE1MjIyMzc3ODUzOTc1OTE5NzI2OTMyMjUwMTQ3OTgyMTE4Mzk5MTEzMDY1ODU0NzY3MDQzNDQzNjUzODQ5Mjc4MzQzNzY0ODY0NDU0OTEwNzA4MjQ4NzU5OTI0ODYzOTcyNTQ3OTg4OTg4NjkxNDQ3MjM0NDgzNjY3OTM2NTQwMTYwNTcxNDI4Njk2OTUxNTUxMzE4MjQ5NDQ4NDc4MDUyNzM1ODk5MDQ2Nzc5NDkxNzIzODI1NDQyMTgyMDY5OTE3NTczNjIyOTEyNzI4NTk4OTg1NzQyNTM5NzEzNjc1MzUyMjU5NjE1MTgzOTg0NzU1OTQ1NDkyNTA5MDU5NTM2ODYzNjE3MDk4NTU2OTIzNjYyMzcyNzc1NzM1OTYzOTY4NTE3ODU3NjE5MjUyNjEyMTk0NDcyMzI0MjI1MjIwNDk0MjEwNjY3MTM1MDgyODQ1NTQ2MTU2NzI4MzU4NDk3MDI4NDQ1NzcyMjQ4NTQ0NDIwODc5MTYwNzI5MTY3MzcxMTQyOTQxOTQyMTE3NDgzNjI0NTE2MTI4MTU1OTk1ODk3OTU3NTgxMTI4OTk1MDExNzg3MDI2NDQ4NzE5MzY4MjE5Mjk0MjExNTgxODYzNzM3MzA5MTY4NjY2NTg1MTY3MDkxMTY3NTUxNTQyNjg4MzU4MDc0MjcyNjg0NzE4OTY5OTY4Mjg5MTQ4ODc5ODQ2NTM3NzMxMTQ4NTEyNDIyODUwODIyNDg2ODMyMjk3Mzk2OTUxNDQyOTYxOTE1NjI0OTk1MjYxOTU1NzUzMDU1NzQ2MDM2NTkxMDYzNzA4MzQzMDMxODQ3MzM5NzI5Mzk2ODEzMjUxNzgzMTc5MjU4MTQwMjkxMTE0MDMyOTc1MjE3NzY3OTY2MzYxNTI3MzY4MTEwNzcyNzg1NjUxMjU5MzM2OTcwMzQxNDMyMjk4MDU3NDM3NzUzMDI3NTU0NTM3MzEzNzU5NjgyNjM0ODEzMTYxODk1NTcxMTM2NjgzMjA5NjQ4MjYzNjc2NTIxNzMwNzE3MjgyMDU0NjY3NjIxMTE0NTU5OTg4OTkzNTEzMzI3MTMyNjUxMTY3OTE3MzE5OTU0Nzc2NzMwMzg4MzA3MTIzNjgyNTI0NDYxNDMzMzYwMzk4NDcxMjU0NjMzNTMzNjkxMDI3MzQ0MTEzNTY5NzM4NjE4MzMwNDk3NzY5NDM4NDUyMjUwMzk3NzYwODU1ODYzMjY0NTU2NTY3ODk0OTE2NTUwNzI0MzI4NTY1NDg1NDUzOTUzODE5MTUzMTgzNjU1NDkyMzIxNjMyOTc1MzYyMjk0MjUwMjIyMTE0MDk2NjIzMjk4MzI3MTcyMTY1NzUzNzExODQyNjgyMjE3NDEyMzUxMzM0MDU0MjIyOTQxNTc0NjI1ODczNDcxOTY1NzcwNTAyOTI5MDgyMTk3NjcwNTkzMjI2NzQ4NjI2NDg2Mjc0NzExMTA3NzU2OTk1NzI0MTM2NTI3MzYwMzU4NzUzNjQ1MDY3OTY0OTg3NTU0OTgyMjI4MjUyOTMxNTgyMzc0NTY4NTMwMzI2MTcyMTE4Njk2MzM4MTU3MzA5ODQ0MTUwODQzNzQ0MzI1NjA0MjEzOTU3Njg1NzI5ODc1NDM5MjA4ODk1MTk3MjIyNTg2NDI2NTk1MjQwMTU2MDMxMTk2NDAzMjg3MjI2MjczNTk5MTIzNDc4MzE1ODMzMzg3MjcyMjE1NzY5NDgyMTQ5MjcwNDM5MjM2NDMyODY5NzQ3ODg3NjI3MjA5MDI2NjU4NDQ3NzM0NzQ1NDQzODE3MDI2NjU3MjQ2OTEyMzU4NjkxMzg5NDY3MjIzMDk3NzI0OTY0NDc2MDM5ODY5MjEwOTkxOTUzNTY2MzM0ODc2NjA0NjgzOTYxNjk2MjcyMzU4MTQzMjk5MjQyMTM1OTkyMTc1MjYyOTg3Njc3NzEyMTIzMDUxMzA5Njg1Njk3NTI3NjMyNTE2MzU1MjYyODU2NzQ2MTg1OTIwNjg4NDg0NzY4OTU4Mzc5MzU1MjM0NjUxNjAzODQ5NzE3NDExODIzMDI0MDcyMzIyOTU1NDg1NjA0OTI2MjU1Mjk1MzE1MjQ1MDU5MDYxNjg3MDIzNzI0NTY3NzU5MDYzMTUwMzg3OTg3MzIzMTg1ODc3MjY2MTYxOTUwMzYxNjM3NzEzNjMwNTYyNDYzODMwODY2NzcxMTU5MTA1Mjk2NzMwNjU5MjQxODYxMDQyNjI0OTM3NTAyMjkwMzQxODIyOTY4ODY0NzU3NTMxNzE1NzY1NjI2MzU4MzE2MTQ0NjY3NjE2NzgyODQwMjUwMTE4Njk3NjgxNzQ1NTU4MTAzNzE4NzQ2OTY0MzA1MzcxNDY5MTEwNTY4MzUyOTYxMDI1OTk3NTA2ODk5NDk2MTIwMzkwODQzNTU2OTk5Njg3MTQyOTQ0MTM5NDI5MzI5ODAzNTg5MjI0NzU5NDI1MjkzMDIzNTg5OTM5NDU5OTI2ODYyOTkyMzc2NDkwNzU2ODU3NjU0MjMyMTQ0NTUyNDc2MzY5MzU2MTYyNDc5NTQxODAzOTYyOTUzMjUxNDI3NzQ3NjUxODg3MjY5MTI5Njg3NDk3MDIyOTU0NzM5NTk2NzUzMzE2NjI2MDk0OTY0MzE2NjU1MzcyMTgyOTYxMjMwMzYzMDY2MzE4NDM5NDgyMzY1NDQxNTE4MzI5MTMxMTM0MDk1MjYxOTU1Mjc0NTA5MjcwNTkzNDMzMTQ3OTY4NzExNTEyNjI1MTAwNDM1NDM4NjEzMTcxMTcwNDQwNDkzMTMwNTUzNTYwMTE3NDc3MjkzODIyMzcyNDU5NzUxODU2MDIzODQwODc2NTkxODYwNDQxMzg5MjY1NzM5MjI1Nzk1MzQ5MzY0MDc0OTY4ODIxMjM2NjI0OTUyNzU4MTUzMDk0MDM1NjM3NDY4NTcxOTYwNjI3NTc5NDMyODQzODY5ODMwNzQ1NTE4ODIzNTgyODg0MDQyMTI0MTczMzQ0Njc2NjU0MzU5MDQ1MzU1MTMzNDU1MjUyNDYzOTg4MTU5NjU2NzM3MjY2NTQzNzkwMTY4NDk0Nzc1MTQ1MTA2MDY2NjQ3OTE1NjU0OTcyMzQwODgyODUwOTQ2MzM3NjIyMjcxOTQzMTIzMjczMjMxODQ4NzU5MjU2NDUyNTE1NDg1NjUxNzU5MDkzNzE5OTczMzc4MzQyODUyODY2ODUxNzA4NjQyMTM1OTcyNzI1Nzg2ODIyNzMyNDU2MTA1NzA2Nzc5OTcyNTY3NzU3NzIxMTI3NDQ3MzA3NzkzNzM3NTk1MTMwMjQzODU0NjA4Mjk1NTg2NTc3NTExMDQ3MzQ1MTE2NDQ2NDIyNzgzNzA4MTE2ODc0MTMyODU2OTI1NTY2OTYzNDQzODgyMDM2NTcwMTUxNzg2NDk4Mjc5NDMyNDQ0OTc2Nzg2MTA0NjI3NzA1NjUxNjY4Mzg2NjY0NzI0NjIxNDQyODc1NDY0MDMyMTE1NDYyNzc1NDM4MzEyMTUzMTI2MzE1NTc5NDQwNTQyMTIyNzEzOTI2OTYwNzg1NjI5NjIyMTczNTQ3MzM5NjY0OTM3Nzg2NzY5MzE0ODE5MjUzOTczNjk1NjQzODk4MTI5Mjg2MjIxODQxOTU3NTE2Mjc2MzA3NzI0MTk5NDI3OTQxMTczOTI3OTgxMjkxNTMzMTI0Njc2NzUxNzIyNjY3NTg0MjI3MzUyNjU5NDcxMjE1ODQ1NzA2NjQ0Njc4NDQyMjk1NTE4NDU5MDQ4NDIyODU2MDI1MTExMDUwMDI1OTM4MjcxOTczNjk3NjgxOTUwMDcyNzU4MjUzNDIxOTU2NDU1NzIzOTI4OTYxMjg3MzM5NzExMDI4NjIzNDcyNjg4MjQxNTE4MjYzNTU1NjkxNTE3Mjg2MjMxMTc1NDM5MjM5NTA1MTE3MzMyNjIwMTEzODc1NzMxODU1NDMyOTU1NzUzMjU1NDc3MTc1MDQ2NzU5NzE5NDczNTQ1ODU1NzYzMjc4MjUxODAzMjUwODYyODgzMzk2OTM0NTg0MjU3NTUwMTQ0MTY1MDgyNjY0NzI4OTE1MTI2NzQ1NDcyMDc5MzY5MDk1MjU0NzI1Mjk3MDI0NjE0Njk5MTIxMjQwNDE3OTk0OTY1MTc5NDg2Nzc5MTQxMjQ0MjUzOTQwNTg0MjQ4NDI4NTQ0NDIwODg4Njk0NjMwMTIxNzIwNDU3MDQ3NTEyNjk5NTI0NzI0NzA4ODg0ODE1MzI1MTIxMTE0NTg3MjU5MjE4MTc5NzUzNTIzNTg5OTM2MDY5NzIxOTE3NDI0Njk1NzQ0MTc4NzE4OTkxNjY0MzE5MTc4NTM0MTYwMzA2NzY1NDg1NDU5NzI0Nzk2NzY5ODc0NDY4NTcxMzU4NTI4Njg1NDQzODIwNzQ0OTIzNzM5MjYzMjI3MTE2ODYyMTUzNjIxMTMyNTY4NDMxMjA1NDU2MTk5MjUwODUyNzY0NTE1MTc0ODc4MTE4NjcyMDU2NTkxMDI2MDk4MjEwMjc0MzMwOTE3MjYyNjUxODk3NjI1NzM5NDY1MzU5NTU3OTEwODgyNTI2MjEzMzI1MDMwMjEzMTMyOTgxNzI1MzUzODEzNzI5MjQwMTUxMjk1MzE1MjU4ODUzMTYwNDk4NjQ1MzM1NjY2OTQyNDgzMjY5NTEwNzYwNTM4OTgyMTM0NzIzNDUwMzc3NTg5ODQ5OTE1ODY1MzA1ODUwNzQxOTk5NzM4NjcxMTI5MjY4NDQyMTU0ODk3ODczNTUxMDY0OTQzNjM4NjI0MTYxMTkyNDc5OTg1MzY1MzI1MzY3NDY0OTU3MTMyNTg0MTU3NjY1NTE2ODY1NjI2MTAzNTIwNjEyMDExNzMwMDczNjI0NDQ0ODkzMTI1NjE1NjY5MzM2MzE5NzEwNzg1NzQzNjI3MDU2ODQxNjk4MjI0MTA3Mjc4MDIwMjIwNDgzNjI0OTM1Mjk5Mzg0MTQxMDQyNzcyNTUzNDI5NDc3ODQ3Mjg2OTgwOTE2NDgxOTI2NDQwNjY0MjczOTE1NzU5MjM1MzEzMzcyOTI4MTkzODQzMDMwNzE0NDUyMjgyNjM4NDU2MDU1MTYyNDU1MDM1NzY4MDIwNzYxMjkwODkzMzA1NzY4NTUxMjMwNDM2MTEwNjk1MjY5MTk4NzI1NzA1NTE5MjM3MDI1MTk0Mzk3MzIzMDY2NzU0NTA0OTc5OTI1NDQ4NDc2Mzk1NzkwMTIzNzc0MTk0Mzg0Nzc3NDkyODY2OTE3MTI0OTc4NTUzODQ1NzE2NDk2MTUzMDU1NzIyNDgzODU5NjgyMjk5NDIxMjYzMDc4NTM3NTExMjY5NjY5OTgxNDgyNzA3NjgyNzI5NDYzMjkwNzc4MjMzOTk3NzA5NzE5NDI4NDEyMzA2NTgzMTU0MDc4NzEwNTM5NTUzMzkwMjU5ODkzMTYzMzkwNjcyODIyMTcwNDY4MjU1MDcxNDk0NzIxODQ2OTU3NTY5MTcwNjUxNzQ2NTY1Mzc0NDMwNjYyNzQ2MTg1OTIwNjc4NTU5NTcxNjcwMjU5ODc0OTc4Njk3Nzk4NDUwMDcxMzgxOTk5MzYwMDY4MTMxNzM4MTMyNzM4OTY4NTU5NzM2NjA4MTA2NzIzOTUyNjA3Njg0NzIzNjMxMTM1NTU1NjYyMTMxMjUwOTg3OTcyNjgzMjkxNDIzMjA1NTAyNTE4NzI1NDcxMTY5NDU2NzE3Njk1MDQwNDg3NjA0OTYxOTU0MzI1NjYxNzIyMjk1ODcxNjcyOTgzMzEyMTQ4NzE5MjM0Njk2NDU2NDk3NzY5NTQ3NTM0NzU4OTk2NzQ4NjgzNjg0Mzc2NDkzMjg4MDUxMzA0MDYzMjc3NzUxNjE4ODYxMjQ4MjU4ODc1NzU2NzIzOTE4NzMxNTg4Mjk2ODQwNzU0NjcxODQwMDU0NTU4MTM3NDkyMzkxMjQ3NjQxMjk5NzIzNDI5NzgzNzM3NDc2MjgyNzY3Njk4MTc2Mzk0MjMzMjk0MTk0MzQyNjU3OTQ5NjEwMDI2MjEwMTgyMjUyODQ1OTc5OTY5NDM4NDUyNzk1MDY5MzQ3NzQxOTUzNTkzMjk4MDUyNTYyNzQxNTk2MTI5NjY5NjgxNTE5NTI2OTU4Njg4NTY4NDI3NTU4ODg5NjM1MzE3OTM5NDc2NTU2MTM3Mjk0NDk5NzEzMDYwMjEzMjg4OTQ3OTY4NDk0MjkxNzI4NzQxOTE4ODYwMTUyOTQ3NDUyODU2ODc1Njk2MjE3MTA5MzUyNzU0NzQxNTUzOTg5NTgxODQwNTAzNTYwOTE1MTY4MzQxMjY4NzI4NjMzNDUzMjc1NDMyMjEzMTExOTcwNTk0MzYzODZkYXRhAA==";
                loadSoundFromUrl(audioDataUrl);
            });

            const clearAudioBtn = document.getElementById('clear-audio-btn');
            clearAudioBtn.addEventListener('click', clearRecordedAudio);

            // Explicit audio arm button (helps on iOS/GitHub Pages)
            const armBtn = document.getElementById('arm-audio-btn');
            const armAudioNow = () => {
                initAudio();
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                if (!droneOscillator) {
                    try { toggleDrone(); } catch {}
                }
                const info = document.getElementById('info-overlay');
                if (info) {
                    info.textContent = 'Audio armed';
                    info.style.opacity = '1';
                    setTimeout(() => { info.style.opacity = '0'; }, 1200);
                }
                if (armBtn) armBtn.style.display = 'none';
            };
            if (armBtn) { armBtn.addEventListener('click', armAudioNow, { passive: true }); }

            // Autoplay safeguards: aggressively arm on multiple gestures (not once-only)
            let audioArmed = false;
            const ensureAudio = () => {
                if (audioArmed && audioContext && audioContext.state === 'running') return;
                initAudio();
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                audioArmed = true;
                if (armBtn) armBtn.style.display = 'none';
            };
            ['pointerdown','mousedown','touchstart','keydown','click'].forEach(evt => {
                window.addEventListener(evt, ensureAudio, { passive: true });
                document.addEventListener(evt, ensureAudio, { passive: true });
            });

            const toggleNamesBtn = document.getElementById('toggle-names-btn');
            toggleNamesBtn.addEventListener('click', () => {
                showNoteNames = !showNoteNames;
                toggleNamesBtn.classList.toggle('active', showNoteNames);
                musicalObjects.forEach(obj => {
                    const label = document.getElementById(`label-${obj.userData.id}`);
                    if (label) {
                        label.style.opacity = showNoteNames ? '1' : '0';
                    }
                });
            });

            const toggleDroneBtn = document.getElementById('toggle-drone-btn');
            toggleDroneBtn.addEventListener('click', () => {
                initAudio();
                toggleDrone();
            });

            const modeSelect = document.getElementById('mode-select');
            const rotationSpeedLabel = document.getElementById('rotation-speed-label');
            modeSelect.addEventListener('change', (e) => {
                currentMode = e.target.value;
                if (currentMode === 'sequencer') {
                    rotationSpeedLabel.textContent = 'Tempo';
                } else {
                    rotationSpeedLabel.textContent = 'Spin';
                }
            });

            const helpBtn = document.getElementById('help-btn');
            const helpScreen = document.getElementById('help-screen');

            helpBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                helpScreen.style.visibility = 'visible';
                helpScreen.style.opacity = '1';
            });

            helpScreen.addEventListener('click', () => {
                helpScreen.style.opacity = '0';
                helpScreen.style.visibility = 'hidden';
            });

            // Rotation speed slider (now also tempo)
            const rotationSlider = document.getElementById('rotation-speed');
            rotationSlider.addEventListener('input', (e) => {
                rotationSpeed = parseFloat(e.target.value);
            });

            // Reverb level slider
            const reverbSlider = document.getElementById('reverb-level');
            if (reverbSlider) {
                reverbSlider.addEventListener('input', (e) => {
                    if (!audioContext) initAudio();
                    if (reverbGain) {
                        reverbGain.gain.setValueAtTime(parseFloat(e.target.value), audioContext.currentTime);
                    }
                });
            }

            // Choir density slider (0..3)
            const choirSlider = document.getElementById('choir-density');
            if (choirSlider) {
                choirSlider.addEventListener('input', (e) => {
                    choirDensity = parseInt(e.target.value, 10) || 0;
                });
            }

            // Plat FX Depth Slider
            const platFxSlider = document.getElementById('plat-fx-depth');
            if (platFxSlider) {
                platFxSlider.addEventListener('input', (e) => {
                    platFxDepth = parseFloat(e.target.value);
                    document.getElementById('plat-fx-label').textContent = platFxDepth.toFixed(2);
                });
            }

            // Two-step loader: Select -> Load (file to per-figure or global)
            const selectBtn = document.getElementById('select-sample-file-btn');
            const loadBtn = document.getElementById('apply-sample-load-btn');
            const hiddenInput = document.getElementById('hidden-sample-file-input');
            const coneTargetSelect = document.getElementById('cone-target-select');
            // Keep lastSelectedFigure synced with cone target dropdown
            if (coneTargetSelect) {
                coneTargetSelect.addEventListener('change', () => {
                    const val = coneTargetSelect.value;
                    if (val === 'all') {
                        lastSelectedFigure = null; // implies global
                    } else {
                        const targetCone = centerCones.find(c => c.userData && c.userData.id === val);
                        if (targetCone) lastSelectedFigure = targetCone;
                    }
                });
            }
            if (selectBtn && loadBtn && hiddenInput) {
                selectBtn.addEventListener('click', () => {
                    hiddenInput.click();
                });
                hiddenInput.addEventListener('change', (e) => {
                    const file = e.target.files && e.target.files[0] ? e.target.files[0] : null;
                    pendingSampleFile = file;
                    loadBtn.disabled = !pendingSampleFile;
                    const info = document.getElementById('info-overlay');
                    if (pendingSampleFile) {
                        info.textContent = `Selected: ${pendingSampleFile.name} ‚Äî press Load to apply (cone if selected, else global)`;
                        info.style.opacity = '1';
                        setTimeout(() => { info.style.opacity = '0'; }, 2000);
                    }
                });
                loadBtn.addEventListener('click', async () => {
                    if (!pendingSampleFile) return;
                    try {
                        initAudio();
                        const arrayBuffer = await pendingSampleFile.arrayBuffer();
                        const buffer = await audioContext.decodeAudioData(arrayBuffer.slice(0));
                        // Respect cone target dropdown if set
                        let target = lastSelectedFigure;
                        if (coneTargetSelect && coneTargetSelect.value && coneTargetSelect.value !== 'all') {
                            target = centerCones.find(c => c.userData && c.userData.id === coneTargetSelect.value) || target;
                        }
                        if (target && target.userData && target.userData.type === 'cone') {
                            target.userData.audioBuffer = buffer;
                            document.getElementById('info-overlay').textContent = `Loaded ${pendingSampleFile.name} for ${target.userData.id}`;
                        } else {
                            recordedAudioBuffer = buffer;
                            document.getElementById('info-overlay').textContent = `Loaded ${pendingSampleFile.name} as global cone sample`;
                        }
                        document.getElementById('info-overlay').style.opacity = '1';
                        setTimeout(() => { document.getElementById('info-overlay').style.opacity = '0'; }, 2200);
                    } catch (err) {
                        console.error('Error decoding selected audio:', err);
                        document.getElementById('info-overlay').textContent = 'Error loading selected file';
                        document.getElementById('info-overlay').style.opacity = '1';
                        setTimeout(() => { document.getElementById('info-overlay').style.opacity = '0'; }, 2000);
                    } finally {
                        pendingSampleFile = null;
                        hiddenInput.value = '';
                        loadBtn.disabled = true;
                    }
                });
            }

            // Update sampler status UI periodically
            setInterval(() => {
                const selLabel = document.getElementById('selected-figure-label');
                const sampleLabel = document.getElementById('sample-status-label');
                if (lastSelectedFigure && lastSelectedFigure.userData && lastSelectedFigure.userData.type === 'cone') {
                    selLabel.textContent = lastSelectedFigure.userData.id;
                    sampleLabel.textContent = lastSelectedFigure.userData.audioBuffer ? 'yes' : 'none';
                } else {
                    selLabel.textContent = 'none (cone)';
                    sampleLabel.textContent = recordedAudioBuffer ? 'global' : 'none';
                }
            }, 300);

            // Reset button now clears sequencer
            document.getElementById('reset-sim-btn').addEventListener('click', () => {
                sequencer = [];
                sequencerNextObjectIndex = 0;
                document.getElementById('info-overlay').textContent = 'Sequencer cleared!';
                document.getElementById('info-overlay').style.opacity = '1';
                setTimeout(() => { document.getElementById('info-overlay').style.opacity = '0'; }, 1500);
            });
        }
        
        function handleObjectClick(object) {
            if (!object.userData) return;
            
            const noteIndex = object.userData.noteIndex;
            let frequency = currentScale[noteIndex % currentScale.length];

            // Use object's position relative to the turntable for sound parameters
            const localPos = object.position.clone(); // position is already local to turntableGroup
            // Clamp to avoid extreme values and normalize to 0-1
            const yFactor = THREE.MathUtils.clamp((localPos.y + 2) / 12, 0, 1);
            const xFactor = THREE.MathUtils.clamp((localPos.x + 10) / 20, 0, 1);
            const zFactor = THREE.MathUtils.clamp((localPos.z + 10) / 20, 0, 1); // Z is depth, so map it

            // Track selection for loaders (cones only)
            if (object.userData.type === 'cone') {
                lastSelectedFigure = object;
                // visual selection hint
                object.children.forEach(child => {
                    if (child.material && child.material.emissive) {
                        child.material.emissive.setHex(0x222222);
                        setTimeout(() => child.material.emissive.setHex(0x000000), 200);
                    }
                });
            }

            // Play behavior
            if (object.userData.type === 'cone') {
                if (object.userData.audioBuffer) {
                    playRecordedSound(object.userData.audioBuffer, yFactor, xFactor, zFactor);
                    drawContextConnection(object.position, new THREE.Vector3(0, 1, 0), 'sample');
                } else if (recordedAudioBuffer) {
                    playRecordedSound(recordedAudioBuffer, yFactor, xFactor, zFactor);
                    drawContextConnection(object.position, new THREE.Vector3(0, 1, 0), 'sample');
                } else {
                    const info = document.getElementById('info-overlay');
                    info.textContent = `${object.userData.id} has no sample loaded, playing root tone`;
                    info.style.opacity = '1';
                    setTimeout(() => { info.style.opacity = '0'; }, 1600);
                    playTone(currentScale[0], yFactor, xFactor, zFactor); // Play root tone if no sample
                }
            } else { // Figure object
                playTone(frequency, yFactor, xFactor, zFactor);
                animateObjectActivation(object);
            }

            // Layered behaviors
            if (enableSequencerLayer && object.userData.type !== 'cone') { // Only figures can be added to sequencer
                object.userData.currentAngularPosition = getObjectAngularPosition(object);
                sequencer.push(object);
                sequencer.sort((a, b) => a.userData.currentAngularPosition - b.userData.currentAngularPosition);
                document.getElementById('info-overlay').textContent = `Added ${object.userData.id} to spinning sequence!`;
                document.getElementById('info-overlay').style.opacity = '1';
                setTimeout(() => { document.getElementById('info-overlay').style.opacity = '0'; }, 1500);
            }
            if (enableChoirLayer) {
                playChoirHarmony(object);
            }

            createWavePropagation(object.position, frequency * yFactor);
            showHarmonicConnections(object, frequency * yFactor);
            updateInfoDisplay(frequency * yFactor, xFactor, zFactor, noteIndex);
        }

        // --- Musical Modes Logic ---
        function playChoirHarmony(activeObject) {
            const userNoteIndex = activeObject.userData.noteIndex;
            const localPos = activeObject.position.clone();
            const yFactor = (localPos.y + 2) / 12;
            const xFactor = (localPos.x + 10) / 20;
            const zFactor = (localPos.z + 10) / 20;

            // User's original tone is already played by handleObjectClick

            const choirObjects = musicalObjects.filter(obj => obj.userData.type === 'figure' && obj !== activeObject);
            
            const harmonyNotes = [
                { index: (userNoteIndex + 2) % currentScale.length, delay: 200, color: 0x4a007f },
                { index: (userNoteIndex + 4) % currentScale.length, delay: 400, color: 0x6a0dad },
                { index: (userNoteIndex + 6) % currentScale.length, delay: 600, color: 0x8a2be2 }
            ];
            
            const selectedChoir = [];
            while(selectedChoir.length < choirDensity && choirObjects.length > 0) {
                const randomIndex = Math.floor(Math.random() * choirObjects.length);
                selectedChoir.push(choirObjects.splice(randomIndex, 1)[0]);
            }
            
            harmonyNotes.forEach((harmony, index) => {
                if (selectedChoir[index]) {
                    const localPosChoir = selectedChoir[index].position.clone();
                    const yFactorChoir = (localPosChoir.y + 2) / 12;
                    const xFactorChoir = (localPosChoir.x + 10) / 20;
                    const zFactorChoir = (localPosChoir.z + 10) / 20;
                    
                    const harmonyFreq = currentScale[harmony.index];
                    setTimeout(() => {
                        playTone(harmonyFreq, yFactorChoir, xFactorChoir, zFactorChoir);
                        animateObjectActivation(selectedChoir[index], harmony.color);
                        createWavePropagation(selectedChoir[index].position, harmonyFreq);
                    }, harmony.delay);
                }
            });
        }

        // No more playSequencer() interval, it's now handled in animate() by turntable rotation

        function toggleDrone() {
            const droneBtn = document.getElementById('toggle-drone-btn');
            if (droneOscillator) {
                droneOscillator.stop();
                droneOscillator = null;
                droneBtn.classList.remove('active');
            } else {
                droneOscillator = audioContext.createOscillator();
                droneOscillator.type = 'triangle';
                droneOscillator.frequency.setValueAtTime(currentScale[0] / 2, audioContext.currentTime);
                droneOscillator.connect(masterGain);
                droneOscillator.start();
                droneBtn.classList.add('active');
            }
        }
        
        // --- Core Functions (Play, Animate, Visualize) ---
        function playTone(frequency, yFactor = 1, xFactor = 0.5, zFactor = 0.5) {
            if (!audioContext) return;
            // Guards to prevent non-finite values
            if (!Number.isFinite(frequency) || frequency <= 0) frequency = 261.63; // C4 fallback
            yFactor = Number.isFinite(yFactor) ? THREE.MathUtils.clamp(yFactor, 0, 1) : 0.5;
            xFactor = Number.isFinite(xFactor) ? THREE.MathUtils.clamp(xFactor, 0, 1) : 0.5;
            zFactor = Number.isFinite(zFactor) ? THREE.MathUtils.clamp(zFactor, 0, 1) : 0.5;
            
            // Gain based on Y position (closer to screen center = louder)
            const volumeGain = audioContext.createGain();
            volumeGain.gain.setValueAtTime(0.18 + yFactor * 0.5, audioContext.currentTime);

            // Panning based on X position
            const panner = audioContext.createStereoPanner();
            panner.pan.setValueAtTime(xFactor * 2 - 1, audioContext.currentTime); // Map 0-1 to -1 to 1

            // Filter based on Z position
            const filter = audioContext.createBiquadFilter();
            filter.type = 'lowpass';
            // Depth (z) controls brightness; Height (y) also shapes resonance for a "laser" timbre
            filter.frequency.setValueAtTime(200 + zFactor * 9800, audioContext.currentTime);
            filter.Q.setValueAtTime(0.5 + yFactor * 6.0, audioContext.currentTime); // higher = more resonant as agent is higher

            const fundamental = audioContext.createOscillator();
            // Subtle pitch bend by Y: +/- 4 semitones around base frequency for sweeter pad
            const semitones = (yFactor - 0.5) * 8; // -4..+4
            const detuneRatio = Math.pow(2, semitones / 12);
            const f0 = Number.isFinite(detuneRatio) ? frequency * detuneRatio : frequency;
            if (!Number.isFinite(f0) || f0 <= 0) return;
            fundamental.frequency.setValueAtTime(f0, audioContext.currentTime);
            fundamental.type = 'sine';

            // Additive synthesis for richer timbre
            const overtones = [2, 3, 4, 5];
            // As agent is higher, emphasize overtones for brighter choir
            const overtoneGains = [0.35, 0.22, 0.15, 0.07].map(g => g * (0.6 + yFactor * 0.8));
            const oscillators = [fundamental];

            for (let i = 0; i < overtones.length; i++) {
                const overtone = audioContext.createOscillator();
                const fi = frequency * detuneRatio * overtones[i];
                overtone.frequency.setValueAtTime(Number.isFinite(fi) && fi > 0 ? fi : frequency * overtones[i], audioContext.currentTime);
                overtone.type = 'triangle';
                
                const overtoneGain = audioContext.createGain();
                overtoneGain.gain.setValueAtTime(overtoneGains[i], audioContext.currentTime);

                overtone.connect(overtoneGain);
                overtoneGain.connect(filter);
                oscillators.push(overtone);
            }
            
            // Gentle ensemble: add two lightly detuned voices for angelic chorus
            const ensemble1 = audioContext.createOscillator();
            ensemble1.type = 'sine';
            {
                const f1 = frequency * Math.pow(2, (semitones - 3) / 12) * 0.999;
                ensemble1.frequency.setValueAtTime(Number.isFinite(f1) && f1 > 0 ? f1 : frequency, audioContext.currentTime);
            }
            const ensemble2 = audioContext.createOscillator();
            ensemble2.type = 'sine';
            {
                const f2 = frequency * Math.pow(2, (semitones + 3) / 12) * 1.001;
                ensemble2.frequency.setValueAtTime(Number.isFinite(f2) && f2 > 0 ? f2 : frequency, audioContext.currentTime);
            }
            const ensembleGain1 = audioContext.createGain();
            const ensembleGain2 = audioContext.createGain();
            ensembleGain1.gain.setValueAtTime(0.08, audioContext.currentTime);
            ensembleGain2.gain.setValueAtTime(0.08, audioContext.currentTime);
            ensemble1.connect(ensembleGain1);
            ensemble2.connect(ensembleGain2);
            ensembleGain1.connect(filter);
            ensembleGain2.connect(filter);

            fundamental.connect(filter);
            filter.connect(panner);
            panner.connect(volumeGain);
            volumeGain.connect(masterGain);
            // Reverb send
            if (reverbConvolver) {
                const reverbSend = audioContext.createGain();
                // Higher agent = more bloom
                reverbSend.gain.setValueAtTime(0.15 + 0.55 * yFactor, audioContext.currentTime);
                panner.connect(reverbConvolver);
                reverbConvolver.connect(reverbGain);
            }
            
            // Envelope
            const now = audioContext.currentTime;
            volumeGain.gain.setValueAtTime(0, now);
            volumeGain.gain.linearRampToValueAtTime(0.28, now + 0.06); // gentler attack
            volumeGain.gain.exponentialRampToValueAtTime(0.01, now + 1.6); // longer tail

            oscillators.forEach(osc => {
                osc.start(now);
                osc.stop(now + 1.0);
            });
            ensemble1.start(now);
            ensemble2.start(now);
            ensemble1.stop(now + 1.0);
            ensemble2.stop(now + 1.0);
        }
        
        function playRecordedSound(buffer, playbackRate = 1, xFactor = 0.5, zFactor = 0.5) {
            if (!audioContext || !buffer) return;
            
            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            source.playbackRate.value = Math.max(0.5, Math.min(playbackRate, 2)); // Map playbackRate to a safe range
            
            const panner = audioContext.createStereoPanner();
            panner.pan.setValueAtTime(xFactor * 2 - 1, audioContext.currentTime);

            const filter = audioContext.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(200 + zFactor * 9800, audioContext.currentTime);

            // Soft gain envelope for samples
            const gainEnv = audioContext.createGain();
            const now = audioContext.currentTime;
            gainEnv.gain.setValueAtTime(0, now);
            gainEnv.gain.linearRampToValueAtTime(0.85, now + 0.03);
            gainEnv.gain.exponentialRampToValueAtTime(0.01, now + Math.min(2.5, buffer.duration + 0.1));

            source.connect(filter);
            filter.connect(panner);
            panner.connect(gainEnv);
            gainEnv.connect(masterGain);
            if (reverbConvolver) {
                panner.connect(reverbConvolver);
            }
            
            source.start();
        }
        
        function animateObjectActivation(object, color = 0x8a2be2, duration = 500) {
            // Store original material color
            const originalColorHex = object.children[0] ? object.children[0].material.color.getHex() : null;
            
            // Animate scale up
            animateProperty({ scale: 1 }, { scale: 1.3 }, duration / 2, (values) => {
                object.scale.setScalar(values.scale);
            }, () => {
                // Animate scale down
                animateProperty({ scale: 1.3 }, { scale: 1 }, duration / 2, (values) => {
                    object.scale.setScalar(values.scale);
                });
            });
            
            // Animate color
            if (object.userData.type === 'figure' && originalColorHex !== null) {
                const colorTarget = new THREE.Color(color);
                object.children.forEach(child => {
                    if (child.material) {
                        child.material.color.copy(colorTarget);
                        setTimeout(() => {
                            child.material.color.setHex(originalColorHex);
                        }, duration);
                    }
                });
            }
        }
        
        function createWavePropagation(origin, frequency) {
            const geometry = new THREE.BufferGeometry();
            const material = new THREE.LineBasicMaterial({ color: 0x8a2be2, linewidth: 2 });
            const line = new THREE.Line(geometry, material);
            line.position.copy(origin);
            line.lookAt(camera.position);

            const startTime = Date.now();
            const duration = 2000;
            
            const animateWave = () => {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / duration;
                if (progress > 1) { turntableGroup.remove(line); return; }
                
                const newPoints = [];
                for (let i = 0; i < 200; i++) {
                    const angle = (i / 200) * Math.PI * 2 * (frequency / 100);
                    const x = (i - 100) * 0.1;
                    const y = Math.sin(angle) * 2 * (1 - progress);
                    newPoints.push(new THREE.Vector3(x, y, 0));
                }
                line.geometry.setFromPoints(newPoints);
                line.position.z -= progress * 5;
                requestAnimationFrame(animateWave);
            };
            turntableGroup.add(line);
            animateWave();
        }

        function showHarmonicConnections(activeObject, frequency) {
            connections.forEach(conn => turntableGroup.remove(conn));
            connections = [];
            
            musicalObjects.forEach(obj => {
                if (obj === activeObject || obj.userData.type !== 'figure') return; // Only figures connect to other figures
                
                const objFreq = currentScale[obj.userData.noteIndex % currentScale.length] * ((obj.position.y + 2) / 12);
                const ratio = frequency / objFreq;
                
                const harmonicRatios = [1, 2, 1.5, 1.25, 4/3, 3/2, 5/4]; // 1, Octave, Fifth, Major Third, Fourth, Fifth, Major Third
                let strength = 0;
                
                harmonicRatios.forEach(r => {
                    const difference = Math.abs(ratio - r);
                    const inverseDifference = Math.abs(1/ratio - r);
                    if (difference < 0.1 || inverseDifference < 0.1) {
                        strength = Math.max(strength, 1 - Math.min(difference, inverseDifference) * 10);
                    }
                });

                if (strength > 0) {
                    const connection = createHarmonicConnection(activeObject.position, obj.position, strength, 'harmonic');
                    turntableGroup.add(connection);
                    connections.push(connection);
                }
            });
            
            setTimeout(() => {
                connections.forEach(conn => turntableGroup.remove(conn));
                connections = [];
            }, 2000);
        }
        
        function createHarmonicConnection(pos1, pos2, strength, type = 'harmonic') {
            const points = [];
            const distance = pos1.distanceTo(pos2);
            const midpoint = new THREE.Vector3().addVectors(pos1, pos2).multiplyScalar(0.5);
            midpoint.y += distance * 0.3; // Give arc height

            // Draw line from pos1 to pos2, with a slight bend
            for (let i = 0; i <= 20; i++) {
                const t = i / 20;
                const point = new THREE.Vector3();
                point.lerpVectors(pos1, pos2, t);
                point.y += Math.sin(t * Math.PI) * distance * 0.3 * strength;
                points.push(point);
            }
            
            const curve = new THREE.CatmullRomCurve3(points);
            const geometry = new THREE.TubeGeometry(curve, 20, 0.05 + strength * 0.1, 8, false);
            let color = 0x8a2be2;
            let opacity = 0.2 + strength * 0.8;
            if (type === 'sequence') { color = 0x44e5ff; opacity = 0.9; }
            if (type === 'sample') { color = 0xffb347; opacity = 0.9; }
            const material = new THREE.MeshBasicMaterial({ color, transparent: true, opacity });
            
            return new THREE.Mesh(geometry, material);
        }

        function drawContextConnection(pos1, pos2, type) {
            const conn = createHarmonicConnection(pos1, pos2, 0.6, type);
            turntableGroup.add(conn);
            setTimeout(() => { turntableGroup.remove(conn); }, 600);
        }

        function updateInfoDisplay(frequency, xFactor, zFactor, noteIndex) {
            const noteName = noteNames[noteIndex % noteNames.length];
            const panValue = (xFactor * 2 - 1).toFixed(2);
            const filterValue = (200 + zFactor * 9800).toFixed(0);
            
            const infoOverlay = document.getElementById('info-overlay');
            infoOverlay.textContent = `Note: ${noteName} (${frequency.toFixed(2)} Hz) | Pan: ${panValue} | Filter: ${filterValue} Hz`;
            infoOverlay.style.opacity = '1';

            setTimeout(() => {
                infoOverlay.style.opacity = '0';
            }, 2000);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function toggleAudioRecording() {
            initAudio();
            const micBtn = document.getElementById('mic-btn');
            
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                micBtn.classList.remove('recording');
                micBtn.textContent = 'üéôÔ∏è';
            } else {
                navigator.mediaDevices.getUserMedia({ audio: true })
                    .then(stream => {
                        mediaRecorder = new MediaRecorder(stream);
                        recordedChunks = [];
                        
                        mediaRecorder.ondataavailable = (event) => {
                            if (event.data.size > 0) {
                                recordedChunks.push(event.data);
                            }
                        };
                        
                        mediaRecorder.onstop = () => {
                            const blob = new Blob(recordedChunks, { type: 'audio/webm' });
                            const reader = new FileReader();
                            reader.onload = (e) => {
                                audioContext.decodeAudioData(e.target.result).then(buffer => {
                                    if (lastSelectedFigure && lastSelectedFigure.userData && lastSelectedFigure.userData.type === 'cone') {
                                        lastSelectedFigure.userData.audioBuffer = buffer;
                                        document.getElementById('info-overlay').textContent = `Recording assigned to ${lastSelectedFigure.userData.id}`;
                                    } else {
                                        recordedAudioBuffer = buffer;
                                        document.getElementById('info-overlay').textContent = 'Audio recording ready (global for cones). Select a cone to assign individually.';
                                    }
                                    document.getElementById('info-overlay').style.opacity = '1';
                                    setTimeout(() => { document.getElementById('info-overlay').style.opacity = '0'; }, 2000);
                                }).catch(err => console.error('Error decoding audio data:', err));
                            };
                            reader.readAsArrayBuffer(blob);
                        };
                        
                        mediaRecorder.start();
                        micBtn.classList.add('recording');
                        micBtn.textContent = 'üî¥';
                    })
                    .catch(err => console.error('Microphone access denied:', err));
            }
        }
        
        function loadSoundFromUrl(url) {
            initAudio();
            document.getElementById('info-overlay').textContent = 'Loading default sound...';
            document.getElementById('info-overlay').style.opacity = '1';
            
            fetch(url)
                .then(response => response.arrayBuffer())
                .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
                .then(audioBuffer => {
                    if (lastSelectedFigure && lastSelectedFigure.userData) {
                        lastSelectedFigure.userData.audioBuffer = audioBuffer;
                        document.getElementById('info-overlay').textContent = `Sound loaded for ${lastSelectedFigure.userData.id}`;
                    } else {
                        recordedAudioBuffer = audioBuffer;
                        document.getElementById('info-overlay').textContent = 'Default sound loaded globally! Select a figure to assign specifically.';
                    }
                    document.getElementById('info-overlay').style.opacity = '1';
                    setTimeout(() => { document.getElementById('info-overlay').style.opacity = '0'; }, 2000);
                })
                .catch(err => {
                    console.error('Error loading audio from URL:', err);
                    document.getElementById('info-overlay').textContent = 'Error loading sound.';
                });
        }
        
        function clearRecordedAudio() {
            if (lastSelectedFigure && lastSelectedFigure.userData) {
                lastSelectedFigure.userData.audioBuffer = null;
                document.getElementById('info-overlay').textContent = `Cleared audio for ${lastSelectedFigure.userData.id}`;
            } else {
                recordedAudioBuffer = null;
                document.getElementById('info-overlay').textContent = 'Cleared global audio!';
            }
            document.getElementById('info-overlay').style.opacity = '1';
            setTimeout(() => { document.getElementById('info-overlay').style.opacity = '0'; }, 2000);
        }

        // --- Whammy (drag-based modulation) helpers ---
        function updateWhammyForObject(object) {
            if (!object || !object.userData) return;
            
            const localPos = object.position.clone();
            const yFactor = THREE.MathUtils.clamp((localPos.y + 2) / 12, 0, 1);
            const xFactor = THREE.MathUtils.clamp((localPos.x + 10) / 20, 0, 1);
            const zFactor = THREE.MathUtils.clamp((localPos.z + 10) / 20, 0, 1);
            
            const noteIndex = object.userData.noteIndex || 0;
            const baseFreq = currentScale[noteIndex % currentScale.length] || 440;
            const displayFreq = baseFreq * ((yFactor - 0.5) * (whammyRangeSemitones / 5) + 1); // rough visual feedback only
            updateInfoDisplay(displayFreq, xFactor, zFactor, noteIndex);
        }

        function stopWhammyForObject(object) {
            // No persistent audio node to reset currently; this exists to prevent ReferenceErrors and for future extension.
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Apply gesture inertia and slider base rotation
            turntableGroup.rotation.y += turntableAngularVelocity + rotationSpeed;
            // Damping for inertia
            turntableAngularVelocity *= 0.96;

            // Global turntable FX (master filter)
            if (audioContext && masterFilter) {
                const rotationMagnitude = Math.abs(turntableAngularVelocity + rotationSpeed);
                const minFreq = 1000; // Even at zero spin, some treble
                const maxFreq = 20000;
                // Map rotation magnitude to filter frequency, use platFxDepth to control sensitivity
                const targetFreq = THREE.MathUtils.lerp(minFreq, maxFreq, rotationMagnitude * 10 * platFxDepth);
                masterFilter.frequency.linearRampToValueAtTime(targetFreq, audioContext.currentTime + 0.1);
            }

            // Pulse the playhead laser slightly with tempo/spin
            if (playheadLaser && playheadBeam) {
                const mag = Math.abs(turntableAngularVelocity + rotationSpeed);
                const pulse = 0.9 + Math.sin(performance.now() * 0.006) * 0.1;
                playheadLaser.intensity = THREE.MathUtils.clamp(1.6 + mag * 18 * pulse, 1.2, 4.0);
                playheadBeam.material.opacity = THREE.MathUtils.clamp(0.08 + mag * 0.5, 0.08, 0.45);
            }

            // Sequencer logic: robust plane-crossing detection against Angel's Gaze (x = 6 plane)
            if (currentMode === 'sequencer' && sequencer.length > 0) {
                const planeX = sequencerReadLine.position.x; // 6
                const nowTime = performance.now();
                for (let i = 0; i < sequencer.length; i++) {
                    const obj = sequencer[i];
                    const worldPos = obj.getWorldPosition(new THREE.Vector3());
                    const prevD = obj.userData.prevDistToReadLine ?? (worldPos.x - planeX);
                    const curD = worldPos.x - planeX;
                    obj.userData.prevDistToReadLine = curD;
                    // crossing from left (negative) to right (positive)
                    if (prevD < 0 && curD >= 0 && (nowTime - (obj.userData.lastTrigger || 0)) > 250) {
                        handleObjectClick(obj);
                        drawContextConnection(obj.position, sequencerReadLine.position, 'sequence');
                        flashPlayheadHalo(worldPos.z);
                        flashLightWall(worldPos.z);
                        animateObjectActivation(obj, 0xffffff, 400);
                        obj.userData.lastTrigger = nowTime;
                        sequencerNextObjectIndex = (i + 1) % sequencer.length;
                        break; // one trigger per frame
                    }
                }
            }

            // Fire flicker and proximity-triggered cone playback
            const nowMs = performance.now();
            centerSpots.forEach((s, i) => {
                const base = 1.3;
                const flicker = 0.85 + Math.random() * 0.3;
                s.intensity = base * flicker;
                if (centerBeams[i]) {
                    centerBeams[i].material.opacity = 0.12 * flicker + 0.06;
                    centerBeams[i].material.color.setHex(0xff7b2c);
                }
            });
            // Trigger cone playback if enough figures nearby
            centerCones.forEach((cone) => {
                const threshold = 3; // people nearby to trigger
                const radius = 3.2;
                let count = 0;
                musicalObjects.forEach(obj => {
                    if (obj.userData && obj.userData.type === 'figure') {
                        if (obj.position.distanceTo(cone.position) <= radius) count++;
                    }
                });
                if (count >= threshold && nowMs - (cone.userData.lastTrigger || 0) > 2000) {
                    // Play cone sample if present; else synth root
                    const localPos = cone.position.clone();
                    const yF = THREE.MathUtils.clamp((localPos.y + 2) / 12, 0, 1);
                    const xF = THREE.MathUtils.clamp((localPos.x + 10) / 20, 0, 1);
                    const zF = THREE.MathUtils.clamp((localPos.z + 15) / 30, 0, 1);
                    if (cone.userData.audioBuffer) {
                        playRecordedSound(cone.userData.audioBuffer, yF, xF, zF);
                    } else if (recordedAudioBuffer) {
                        playRecordedSound(recordedAudioBuffer, yF, xF, zF);
                    } else {
                        playTone(currentScale[0], yF, xF, zF);
                    }
                    // Harmonize with nearby figures
                    musicalObjects.forEach(obj => {
                        if (obj.userData && obj.userData.type === 'figure') {
                            if (obj.position.distanceTo(cone.position) <= radius) {
                                const fIdx = obj.userData.noteIndex % currentScale.length;
                                playTone(currentScale[fIdx], (obj.position.y + 2) / 12, (obj.position.x + 10) / 20, (obj.position.z + 15) / 30);
                                drawContextConnection(cone.position, obj.position, 'harmonic');
                            }
                        }
                    });
                    cone.userData.lastTrigger = nowMs;
                }
                // Flicker flame sprite height/opacity
                if (cone.userData.flame) {
                    const f = 0.9 + Math.random() * 0.3;
                    cone.userData.flame.scale.y = f * 1.2;
                    cone.userData.flame.material.opacity = 0.75 + Math.random() * 0.25;
                }
            });

            musicalObjects.forEach((obj) => {
                if (obj.userData) {
                    const label = document.getElementById(`label-${obj.userData.id}`);
                    if (label) {
                        const vector = new THREE.Vector3();
                        const worldPos = obj.getWorldPosition(vector);
                        worldPos.project(camera);
                        const rect = renderer.domElement.getBoundingClientRect();
                        const x = (worldPos.x * 0.5 + 0.5) * rect.width + rect.left;
                        const y = (-worldPos.y * 0.5 + 0.5) * rect.height + rect.top;
                        label.style.left = `${x}px`;
                        label.style.top = `${y}px`;
                    }
                }
            });

            // Keep camera looking at center
            camera.lookAt(0, 4, 0);
            
            renderer.render(scene, camera);
        }

        // Visual halo beneath the playhead at the object's z when it triggers
        function flashPlayheadHalo(zAt) {
            const radius = 0.6;
            const ringGeom = new THREE.RingGeometry(radius * 0.6, radius, 32);
            const ringMat = new THREE.MeshBasicMaterial({ color: 0xb8c7ff, transparent: true, opacity: 0.6, side: THREE.DoubleSide, blending: THREE.AdditiveBlending });
            const ring = new THREE.Mesh(ringGeom, ringMat);
            ring.rotation.x = -Math.PI / 2;
            ring.position.set(sequencerReadLine.position.x, 0.05, zAt);
            scene.add(ring);
            // fade out
            const start = performance.now();
            const dur = 350;
            function tick() {
                const t = (performance.now() - start) / dur;
                if (t >= 1) { scene.remove(ring); return; }
                ring.material.opacity = 0.6 * (1 - t);
                ring.scale.setScalar(1 + t * 0.5);
                requestAnimationFrame(tick);
            }
            requestAnimationFrame(tick);
        }
        
        function animateProperty(from, to, duration, onUpdate, onComplete) {
            const start = performance.now();
            function tick(now) {
                const elapsed = now - start;
                const progress = Math.min(elapsed / duration, 1);
                const values = {};
                for (const key in from) {
                    values[key] = from[key] + (to[key] - from[key]) * progress;
                }
                onUpdate(values);
                if (progress < 1) {
                    requestAnimationFrame(tick);
                } else if (onComplete) {
                    onComplete();
                }
            }
            requestAnimationFrame(tick);
        }
        
        function addNoteLabels() {
            musicalObjects.forEach(obj => {
                if (obj.userData) {
                    const labelDiv = document.createElement('div');
                    labelDiv.className = 'note-label';
                    labelDiv.id = `label-${obj.userData.id}`;
                    labelDiv.textContent = noteNames[obj.userData.noteIndex % noteNames.length];
                    document.body.appendChild(labelDiv);
                }
            });
        }
        
        window.onload = () => {
            init();
        };
    </script>
</body>
</html>