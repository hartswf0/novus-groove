<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Ethereal Harmony Canvas</title>
    <link rel="icon" href="data:," />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap');
        
        :root {
            --neon-blue: #00e5ff;
            --neon-purple: #cc33ff;
            --neon-yellow: #ffff00;
            --dark-background: #0d0d1a;
            --control-bg: rgba(0, 0, 0, 0.7);
            --text-color: #eee;
        }

        html, body { height: 100%; }
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: var(--dark-background);
            font-family: 'Space Mono', monospace;
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            height: 100vh;
            -webkit-user-select: none;
            user-select: none;
        }
        
        #container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            flex: 1;
            display: block;
            touch-action: none;
        }
        @supports (height: 100dvh) { #container { height: 100dvh; } }
        @supports (-webkit-touch-callout: none) { html, body { height: -webkit-fill-available; } #container { height: -webkit-fill-available; } }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        #info-overlay {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: var(--neon-purple);
            padding: 10px 20px;
            border-radius: 10px;
            font-family: 'Space Mono', monospace;
            font-size: 14px;
            transition: opacity 0.5s ease-in-out;
            user-select: none;
            z-index: 100;
        }
        
        #controls-panel {
            position: absolute;
            top: 24px;
            right: 24px;
            background: var(--control-bg);
            backdrop-filter: blur(10px) saturate(120%);
            -webkit-backdrop-filter: blur(10px) saturate(120%);
            padding: 12px;
            border-radius: 14px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            transition: transform 0.3s ease-in-out, opacity 0.3s;
            transform: translateX(120%);
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 8px;
            user-select: none;
            font-family: 'Space Mono', monospace;
            max-height: calc(100vh - 48px);
            overflow-y: auto;
            max-width: 280px; /* Keep panel small for minimal version */
        }

        #controls-panel.active {
            transform: translateX(0);
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.08);
            color: #e5faff;
            border: 1px solid rgba(255, 255, 255, 0.12);
            padding: 8px 12px;
            border-radius: 999px; /* Pill shape */
            cursor: pointer;
            font-size: 14px;
            min-width: 44px;
            min-height: 36px;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s, transform 0.15s, box-shadow 0.2s, border-color 0.2s;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.25);
            white-space: nowrap;
        }
        
        .control-btn:hover {
            background: rgba(255, 255, 255, 0.16);
            transform: translateY(-1px);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .control-btn.active {
            background: var(--neon-purple);
            box-shadow: 0 0 12px rgba(204, 51, 255, 0.6);
            border-color: rgba(204, 51, 255, 0.6);
        }
        
        #toggle-controls-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.08);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.12);
            padding: 8px 12px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 14px;
            z-index: 101;
            transition: transform 0.2s, background-color 0.2s, border-color 0.2s;
        }

        #toggle-controls-btn:hover {
            background: rgba(255, 255, 255, 0.16);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .slider-group {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 6px;
        }
        .slider-group label {
            color: #ddd;
            font-size: 12px;
            letter-spacing: 0.04em;
        }
        .slider-group input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 140px;
            height: 4px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 999px;
            outline: none;
        }
        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--neon-purple);
            box-shadow: 0 0 0 4px rgba(204, 51, 255, 0.25);
            cursor: pointer;
        }
        .slider-group input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--neon-purple);
            box-shadow: 0 0 0 4px rgba(204, 51, 255, 0.25);
            cursor: pointer;
        }
        
        #help-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            font-family: 'Space Mono', monospace;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            z-index: 200;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease-in-out, visibility 0.5s;
        }

        #help-screen h2 {
            font-size: 2em;
            margin-bottom: 20px;
            color: var(--neon-blue);
        }

        #help-screen ul {
            list-style: none;
            padding: 0;
            text-align: left;
            max-width: 600px;
            font-size: 1.2em;
        }

        #help-screen li {
            margin-bottom: 15px;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
        }

        .note-label {
            position: absolute;
            color: var(--neon-yellow);
            font-family: 'Space Mono', monospace;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 0 0 8px var(--neon-yellow), 0 0 4px rgba(0,0,0,0.8);
            transform: translate(-50%, -50%);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 10;
        }

        @media (max-width: 768px) {
            #controls-panel {
                top: 8px;
                right: 8px;
                padding: 8px;
                max-height: calc(100vh - 16px);
                max-width: calc(100vw - 16px);
            }
            #toggle-controls-btn {
                top: 8px;
                right: 8px;
                padding: 6px 10px;
                font-size: 12px;
            }
            .slider-group input[type="range"] {
                width: 100%;
                max-width: 100%;
            }
            #info-overlay {
                bottom: 10px;
                left: 10px;
                padding: 8px 12px;
                font-size: 12px;
            }
            #help-screen h2 {
                font-size: 1.5em;
            }
            #help-screen ul {
                font-size: 1em;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <!-- 3D Scene Canvas is added by JS -->
    </div>

    <div id="info-overlay">Tap on ethereal figures to evoke polyphonic harmonies.</div>
    <button id="toggle-controls-btn">☰</button>
    <div id="controls-panel">
        <div class="slider-group">
            <label for="rotation-speed">Spin</label>
            <input id="rotation-speed" type="range" min="-0.05" max="0.05" step="0.001" value="0" />
        </div>
        <button id="toggle-names-btn" class="control-btn">Abc Notes</button>
        <div style="display:flex; gap:6px; align-items:center;">
            <button id="help-btn" class="control-btn">?</button>
            <button id="full-screen-btn" class="control-btn" title="Fullscreen">⤢</button>
        </div>
    </div>
    
    <div id="help-screen">
        <h2>Guidance from the Angel of History</h2>
        <ul>
            <li><b>Interaction:</b> Tap ethereal figures to evoke harmony. Drag a figure to shape its sound:
                <ul>
                    <li><b>Vertical (Y-axis)</b>: Pitch (higher = higher frequency).</li>
                    <li><b>Horizontal (X-axis)</b>: Stereo Pan (left/right).</li>
                    <li><b>Depth (Z-axis)</b>: Filter Cutoff (forward = brighter, back = darker).</li>
                    <li><b>Distance from Center (XZ-plane)</b>: Affects Filter Resonance and overall Voice Gain.</li>
                </ul>
            </li>
            <li><b>Harmony</b>: Each figure generates a simple, angelic chord in C Major.</li>
            <li><b>Connections</b>:
                <ul>
                    <li><span style="color:var(--neon-purple);">Purple arcs</span> = harmonic relationships.</li>
                </ul>
            </li>
            <li><b>Turntable</b>: Use the 'Spin' slider to rotate the scene.</li>
            <li>Tap this screen to close.</li>
        </ul>
    </div>

<script>
    /* =============================================
       ETHEREAL HARMONY CANVAS - MINIMAL VERSION
       - Simplified 3D scene: celestial environment, angelic figures.
       - Core Audio: Polyharmonic Voice class for spatial sound.
       - Minimal UI: Spin, Toggle Names, Help.
       - Focus: Delightful, intuitive interaction.
       - FIX: AudioContext initialization moved to first user interaction.
       ============================================= */

    /* ====== GLOBAL STATE & UTILITIES ====== */
    let audioContext, isAudioInitialized = false;
    let masterGain; // Only masterGain needed for simplicity
    let synthOutGain; // All voices connect here
    let reverbDelay, reverbFeedbackGain, reverbWetGain; // Simplified reverb

    // Three.js Scene Variables
    let scene, camera, renderer;
    let turntableGroup;
    let backboardGroup;
    let musicalObjects = []; // Angel figures (initially created without Voice objects)
    let connections = [];
    let raycaster;
    let pointer;
    let showNoteNames = false;

    let draggableObjects = []; // Angel figures
    let isDragging = false;
    let activeObject = null;
    const dragPlane = new THREE.Plane();
    const dragOffset = new THREE.Vector3();
    let rotationSpeed = 0.0;
    let turntableAngularVelocity = 0.0;
    let isRotDragging = false;
    let lastRotX = 0;
    let lastRotTime = 0;

    // Fixed Audio Parameters for minimal version
    const BASE_FREQ = 261.63; // C4
    const BASE_CUTOFF = 4000; // Default filter cutoff
    const REVERB_FEEDBACK = 0.5; // Fixed delay time
    const REVERB_WET_DRY = 0.3; // Fixed reverb amount
    const HARM_TONES = 4; // A simple triad + octave
    const CHORD_STEPS = [0, 4, 7, 12]; // C E G C (C Major Triad + Octave)
    const SCALE_STEPS = [0, 2, 4, 5, 7, 9, 11]; // C Major
    const DETUNE_CENTS = 8; // Slight detune for richness
    const STEREO_SPREAD = 0.6; // Moderate stereo spread
    const DRIFT = 0.2; // Subtle pitch drift
    const SOFT_LP_FREQ = 9000; // General high-frequency roll-off (used for a global lowpass)

    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

    /* ====== AUDIO CORE INITIALIZATION ====== */
    function initAudio() {
        if (isAudioInitialized) return;
        audioContext = new (window.AudioContext || window.webkitAudioContext)();

        masterGain = audioContext.createGain();
        masterGain.gain.value = 0.6; // Overall master volume
        masterGain.connect(audioContext.destination);

        // Simplified Reverb/Delay (pre-delay for a more spacious feel)
        reverbDelay = audioContext.createDelay(1.0); // Max 1 second delay
        reverbFeedbackGain = audioContext.createGain(); // For feedback loop
        reverbWetGain = audioContext.createGain(); // For wet signal amount

        // Feedback loop for reverb
        reverbDelay.connect(reverbFeedbackGain);
        reverbFeedbackGain.connect(reverbDelay); // Connect feedback back to delay input

        // Global soft lowpass for synth output
        const globalSoftLP = audioContext.createBiquadFilter();
        globalSoftLP.type = 'lowpass';
        globalSoftLP.frequency.value = SOFT_LP_FREQ;
        globalSoftLP.Q.value = 0.5;

        synthOutGain = audioContext.createGain(); // All voices connect here
        synthOutGain.connect(globalSoftLP); // All synth audio goes through global LP
        globalSoftLP.connect(reverbDelay); // Send processed signal to delay
        globalSoftLP.connect(masterGain); // Also send dry processed signal directly to master

        // Set initial reverb parameters
        reverbDelay.delayTime.value = 0.3; // Short delay
        reverbFeedbackGain.gain.value = REVERB_FEEDBACK; // Amount of feedback
        reverbWetGain.gain.value = REVERB_WET_DRY; // Overall wet signal to master
        reverbDelay.connect(reverbWetGain); // Connect delay to wet gain
        reverbWetGain.connect(masterGain); // Connect wet signal to master

        isAudioInitialized = true;
    }

    /* ====== MUSIC THEORY HELPERS ====== */
    function midiToHz(m) { return 440 * Math.pow(2, (m - 69) / 12); }
    function hzToMidi(h) { return 69 + 12 * Math.log2(h / 440); }
    function quantizeToScale(hz) {
        const midi = hzToMidi(hz);
        const octave = Math.floor(midi / 12) * 12;
        const stepInOctave = midi - octave;

        let bestStep = SCALE_STEPS[0], minDiff = Math.abs(stepInOctave - SCALE_STEPS[0]);
        for (const s of SCALE_STEPS) {
            const d = Math.abs(stepInOctave - s);
            if (d < minDiff) { minDiff = d; bestStep = s; }
        }
        const qMidi = octave + bestStep;
        return midiToHz(qMidi);
    }
    function getChordOffsets(count) {
        const arr = [];
        for (let i = 0; i < count; i++) {
            arr.push(CHORD_STEPS[i % CHORD_STEPS.length] + 12 * Math.floor(i / CHORD_STEPS.length));
        }
        return arr.slice(0, count);
    }

    /* ====== VOICE CLASS ====== */
    class Voice {
        constructor(nx, ny, nz, nr) {
            // Ensure audioContext is initialized before creating any audio nodes
            if (!audioContext) {
                console.error("AudioContext not initialized when trying to create Voice.");
                return; 
            }

            this.children = [];
            this.gain = audioContext.createGain();
            this.pan = audioContext.createStereoPanner();
            this.filter = audioContext.createBiquadFilter(); this.filter.type = 'lowpass'; this.filter.Q.value = 0.6;
            this.env = audioContext.createGain();

            this.env.connect(this.filter);
            this.filter.connect(this.pan);
            this.pan.connect(this.gain);
            this.gain.connect(synthOutGain); // Connects to the main synth output

            this.active = true; // Voice is active as long as it exists.
            this._rebuildOscs(BASE_FREQ); // Initial build of oscillators
            this.updateParameters(nx, ny, nz, nr);

            // Simple ADSR-like envelope: attack quickly, then sustain and release quickly
            this.env.gain.cancelScheduledValues(audioContext.currentTime);
            this.env.gain.linearRampToValueAtTime(0.0001, audioContext.currentTime);
            this.env.gain.linearRampToValueAtTime(1.0 / HARM_TONES, audioContext.currentTime + 0.01); // Quick attack
            // Voice stays at this level until explicitly stopped or updated.
        }

        setGain(g) { this.gain.gain.setTargetAtTime(g, audioContext.currentTime, 0.02); }
        
        _rebuildOscs(freqBase) {
            this.children.forEach(ch => {
                try { ch.osc.stop(); ch.osc.disconnect(); ch.lfo.stop(); ch.lfo.disconnect(); ch.lfoGain.disconnect(); ch.driftHzAdder.disconnect(); } catch { }
            });
            this.children.length = 0;

            const offsets = getChordOffsets(HARM_TONES);

            for (let i = 0; i < offsets.length; i++) {
                const cents = (i - (offsets.length - 1) / 2) * DETUNE_CENTS;
                const ratio = Math.pow(2, cents / 1200);

                const midiBase = hzToMidi(freqBase);
                const noteHz = quantizeToScale(midiToHz(midiBase + offsets[i])) * ratio;

                const osc = audioContext.createOscillator(); osc.type = 'sine';
                osc.frequency.value = noteHz;
                osc.connect(this.env);

                // LFO for subtle pitch drift
                const lfo = audioContext.createOscillator(); lfo.type = 'sine';
                lfo.frequency.value = 0.03 + DRIFT * 0.4 + Math.random() * 0.02;
                const lfoGain = audioContext.createGain();
                lfoGain.gain.value = 2 + DRIFT * 9;

                const driftHzAdder = audioContext.createGain();
                driftHzAdder.gain.value = noteHz * (Math.log(2) / 1200);

                lfo.connect(lfoGain);
                lfoGain.connect(driftHzAdder);
                driftHzAdder.connect(osc.frequency);

                osc.start(); lfo.start();

                const panPos = (i / (offsets.length - 1 || 1)) * 2 - 1; // Panning for individual chord tones

                this.children.push({ osc, lfo, lfoGain, driftHzAdder, baseHz: noteHz, panPos });
            }
        }

        updateParameters(nx, ny, nz, nr) { // nx, ny, nz are normalized 3D coords, nr is radius in XZ
            const pitchRange = 2; // ±2 octaves by vertical position (ny from -1 to 1)
            let f0 = BASE_FREQ * Math.pow(2, ny * pitchRange);
            f0 = quantizeToScale(f0);

            // Filter cutoff from z (depth) and x (horizontal)
            let cutoff = BASE_CUTOFF * (1 + (nz * 0.5) + (nx * 0.3)); // z has more influence
            cutoff = Math.max(80, Math.min(audioContext.sampleRate / 2, cutoff));
            this.filter.frequency.setTargetAtTime(cutoff, audioContext.currentTime, 0.02);
            // Filter Q from radius from center (nr)
            this.filter.Q.setTargetAtTime(0.6 + nr * 4.0, audioContext.currentTime, 0.03);

            // Retune existing oscillators
            const offsets = getChordOffsets(HARM_TONES);
            for (let i = 0; i < this.children.length; i++) {
                const cents = (i - (offsets.length - 1) / 2) * DETUNE_CENTS;
                const ratio = Math.pow(2, cents / 1200);
                const midiBase = hzToMidi(f0);
                const noteHz = quantizeToScale(midiToHz(midiBase + offsets[i])) * ratio;
                this.children[i].baseHz = noteHz;
                this.children[i].osc.frequency.setTargetAtTime(noteHz, audioContext.currentTime, 0.03);
            }

            // Pan spread based on X position and STEREO_SPREAD
            const basePan = nx; // -1 to 1 based on horizontal position
            const spread = STEREO_SPREAD;

            const effectivePanSum = this.children.reduce((acc, ch) => {
                const childPan = (1 - spread) * 0 + spread * ch.panPos;
                return acc + childPan;
            }, 0);
            const effectivePan = effectivePanSum / (this.children.length || 1);

            const finalPan = Math.max(-1, Math.min(1, basePan * 0.5 + effectivePan * 0.5));
            this.pan.pan.setTargetAtTime(finalPan, audioContext.currentTime, 0.03);

            // Voice gain gentle with radius from center
            const minG = 0.04, maxG = 0.75;
            const g = minG + nr * (maxG - minG); this.setGain(g);
        }

        stop() {
            try {
                const now = audioContext.currentTime;
                this.env.gain.cancelScheduledValues(now);
                this.env.gain.setTargetAtTime(0.0001, now, 0.05); // Rapid decay
                setTimeout(() => {
                    try {
                        this.children.forEach(ch => {
                            ch.osc.stop(); ch.osc.disconnect();
                            ch.lfo.stop(); ch.lfo.disconnect();
                            ch.lfoGain.disconnect();
                            ch.driftHzAdder.disconnect();
                        });
                        this.pan.disconnect();
                        this.filter.disconnect();
                        this.gain.disconnect();
                        this.env.disconnect();
                    } catch (e) { console.warn("Error stopping voice components:", e); }
                }, 100);
            } catch (e) { console.warn("Error stopping voice:", e); }
        }
    }

    /* ====== THREE.JS SCENE SETUP ====== */
    function init() {
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x0a001a, 10, 100); // Deep space fog
        const vw = (window.visualViewport ? Math.floor(window.visualViewport.width) : window.innerWidth);
        const vh = (window.visualViewport ? Math.floor(window.visualViewport.height) : window.innerHeight);
        camera = new THREE.PerspectiveCamera(75, vw / vh, 0.1, 1000);
        camera.position.set(0, 5, 15);
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: 'high-performance' });
        renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
        renderer.setSize(vw, vh);
        renderer.setClearColor(0x0a001a, 0.8); // Dark cosmic background
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('container').appendChild(renderer.domElement);

        raycaster = new THREE.Raycaster();
        pointer = new THREE.Vector2();

        turntableGroup = new THREE.Group();
        scene.add(turntableGroup);

        backboardGroup = new THREE.Group(); // For the static staff
        scene.add(backboardGroup);

        setupLighting();
        createCelestialEnvironment();
        createAngelFigures(); // Figures are created here, but their Voice objects are null initially
        setupEventListeners();
        addNoteLabels();

        addResizeHandlers();
        animateThreeJS();
    }

    function addResizeHandlers() {
        function onResize() {
            const vw = (window.visualViewport ? Math.floor(window.visualViewport.width) : window.innerWidth);
            const vh = (window.visualViewport ? Math.floor(window.visualViewport.height) : window.innerHeight);
            camera.aspect = vw / vh;
            camera.updateProjectionMatrix();
            renderer.setSize(vw, vh);
            renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
        }
        window.addEventListener('resize', onResize, { passive: true });
        window.addEventListener('orientationchange', onResize, { passive: true });
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', onResize, { passive: true });
        }
    }

    function setupLighting() {
        const ambientLight = new THREE.AmbientLight(0x2d004d, 0.6); // Soft purple ambient
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0x4a007f, 0.8); // Stronger purple directional
        directionalLight.position.set(10, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);
    }

    function createCelestialEnvironment() {
        // Dark, reflective floor
        const floorGeometry = new THREE.PlaneGeometry(30, 30);
        const floorMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x1a0a2a,
            roughness: 0.2,
            metalness: 0.1,
            reflectivity: 0.8,
            clearcoat: 0.1,
            clearcoatRoughness: 0.2,
            transparent: true,
            opacity: 0.9
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        turntableGroup.add(floor);

        // Subtle glowing grid
        const gridHelper = new THREE.GridHelper(30, 30, 0x4a007f, 0x4a007f);
        gridHelper.material.transparent = true;
        gridHelper.material.opacity = 0.3;
        turntableGroup.add(gridHelper);

        // Ethereal back wall (cosmic horizon)
        const wallGeometry = new THREE.PlaneGeometry(20, 12);
        const wallMaterial = new THREE.MeshBasicMaterial({
            color: 0x0a001a,
            transparent: true,
            opacity: 0.7,
            blending: THREE.AdditiveBlending
        });
        const wall = new THREE.Mesh(wallGeometry, wallMaterial);
        wall.position.set(0, 6, -10);
        turntableGroup.add(wall);

        // Musical staff as ancient glyphs (purely visual in this minimal version)
        for (let i = 0; i < 5; i++) {
            const lineGeometry = new THREE.BoxGeometry(18, 0.15, 0.1);
            const lineMaterial = new THREE.MeshBasicMaterial({ color: 0x8a2be2, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending });
            const line = new THREE.Mesh(lineGeometry, lineMaterial);
            line.position.set(0, 4 + i * 0.8, -9.9);
            backboardGroup.add(line);
        }

        // Iridescent rotating disc
        const discGeom = new THREE.CylinderGeometry(16, 16, 0.2, 64);
        const discMat = new THREE.MeshPhysicalMaterial({
            color: 0x1a1a1f,
            roughness: 0.5,
            metalness: 0.8,
            clearcoat: 1.0,
            clearcoatRoughness: 0.1,
            reflectivity: 1.0,
            iridescence: 1.0,
            iridescenceIOR: 1.3,
            iridescenceThicknessRange: [100, 400]
        });
        const disc = new THREE.Mesh(discGeom, discMat);
        disc.position.set(0, 0.1, 0);
        disc.receiveShadow = true;
        turntableGroup.add(disc);
    }

    function createAngelFigures() {
        const figurePositions = [
            [-8, 1, 5], [-4, 1, 8], [0, 1, 8], [4, 1, 8], [8, 1, 5],
            [-8, 1, 0], [8, 1, 0],
            [-8, 1, -5], [-4, 1, -5], [4, 1, -5], [8, 1, -5]
        ];

        figurePositions.forEach((pos, index) => {
            const figure = createAngelFigureMesh();
            figure.position.set(...pos);
            
            figure.userData = {
                id: `figure-${index}`,
                type: 'figure',
                noteIndex: index, // For display
                originalPosition: new THREE.Vector3(...pos),
                isDraggable: true,
                voice: null // Voice will be instantiated on first interaction
            };
            turntableGroup.add(figure);
            musicalObjects.push(figure);
            draggableObjects.push(figure);
        });
    }

    function createAngelFigureMesh() {
        const group = new THREE.Group();

        // Ethereal Body (glowing, translucent cylinder)
        const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.4, 1.2, 8);
        const bodyMaterial = new THREE.MeshPhongMaterial({
            color: 0x8a2be2,
            emissive: 0x8a2be2,
            emissiveIntensity: 0.4,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.castShadow = true;
        group.add(body);

        // Head (glowing sphere)
        const headGeometry = new THREE.SphereGeometry(0.25, 8, 8);
        const headMaterial = new THREE.MeshPhongMaterial({
            color: 0x8a2be2,
            emissive: 0x8a2be2,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending
        });
        const head = new THREE.Mesh(headGeometry, headMaterial);
        head.position.y = 0.85;
        head.castShadow = true;
        group.add(head);

        // Subtle Wings (thin planes with a gradient or texture, glowing)
        const wingGeometry = new THREE.PlaneGeometry(0.8, 0.8);
        const wingMaterial = new THREE.MeshBasicMaterial({
            color: 0xcc33ff, // Neon purple for wings
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.4,
            blending: THREE.AdditiveBlending
        });

        const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
        leftWing.position.set(-0.6, 0.4, -0.2);
        leftWing.rotation.y = -Math.PI / 4;
        leftWing.rotation.z = 0.5;
        group.add(leftWing);

        const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
        rightWing.position.set(0.6, 0.4, -0.2);
        rightWing.rotation.y = Math.PI / 4;
        rightWing.rotation.z = -0.5;
        group.add(rightWing);

        return group;
    }

    /* ====== EVENT LISTENERS AND UI LOGIC ====== */
    function setupEventListeners() {
        function onPointerDown(event) {
            initAudio(); // Ensure audio context is created on first user interaction
            audioContext.resume(); // Ensure audio context is not suspended

            const rect = renderer.domElement.getBoundingClientRect();
            const cx = (event.clientX - rect.left) / rect.width;
            const cy = (event.clientY - rect.top) / rect.height;
            pointer.x = cx * 2 - 1;
            pointer.y = -(cy * 2 - 1);

            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(musicalObjects, true);

            if (intersects.length > 0) {
                // Resolve to ancestor carrying userData.type
                let cur = intersects[0].object;
                while (cur && (!cur.userData || !cur.userData.type) && cur.parent) cur = cur.parent;
                const clickedObject = cur || intersects[0].object;
                handleObjectClick(clickedObject);

                if (clickedObject.userData && clickedObject.userData.isDraggable) {
                    isDragging = true;
                    activeObject = clickedObject;
                    const intersectionPoint = intersects[0].point;
                    const camDir = new THREE.Vector3();
                    camera.getWorldDirection(camDir);
                    dragPlane.setFromNormalAndCoplanarPoint(camDir, intersectionPoint);
                    dragOffset.subVectors(activeObject.position, intersectionPoint);
                }
            } else {
                // Begin turntable drag
                isRotDragging = true;
                lastRotX = event.clientX;
                lastRotTime = performance.now();
            }
        }

        function onPointerMove(event) {
            if (!isDragging || !activeObject) return;

            const rect = renderer.domElement.getBoundingClientRect();
            const cx = (event.clientX - rect.left) / rect.width;
            const cy = (event.clientY - rect.top) / rect.height;
            pointer.x = cx * 2 - 1;
            pointer.y = -(cy * 2 - 1);

            raycaster.setFromCamera(pointer, camera);
            const newPosition = new THREE.Vector3();
            raycaster.ray.intersectPlane(dragPlane, newPosition);

            activeObject.position.copy(newPosition).add(dragOffset);

            // Keep the object in a reasonable range
            activeObject.position.x = Math.max(-10, Math.min(10, activeObject.position.x));
            activeObject.position.y = Math.max(-2, Math.min(10, activeObject.position.y));
            activeObject.position.z = Math.max(-10, Math.min(10, activeObject.position.z));

            updateVoiceParametersFromObject(activeObject);
        }

        function onPointerUp(event) {
            isDragging = false;
            activeObject = null;
            
            if (isRotDragging) {
                const now = performance.now();
                const dx = event && event.clientX != null ? (event.clientX - lastRotX) : 0;
                const dt = Math.max(1, now - lastRotTime);
                const velocity = (dx / dt) * 0.01; // Direct control for minimal version
                turntableAngularVelocity = velocity;
                isRotDragging = false;
            }
        }

        renderer.domElement.addEventListener('pointerdown', onPointerDown);
        renderer.domElement.addEventListener('pointermove', (e) => {
            if (isRotDragging) {
                const now = performance.now();
                const dx = e.clientX - lastRotX;
                turntableGroup.rotation.y += dx * 0.003;
                lastRotX = e.clientX;
                lastRotTime = now;
            }
            onPointerMove(e);
        });
        renderer.domElement.addEventListener('pointerup', onPointerUp);
        renderer.domElement.addEventListener('pointerleave', onPointerUp);
        renderer.domElement.addEventListener('pointercancel', onPointerUp);

        window.addEventListener('resize', onWindowResize);

        // Fullscreen
        const fsBtn = document.getElementById('full-screen-btn');
        function isFullscreen() { return !!(document.fullscreenElement || document.webkitFullscreenElement); }
        async function toggleFullscreen() {
            try {
                const target = document.getElementById('container') || document.documentElement;
                if (!isFullscreen()) {
                    if (target.requestFullscreen) await target.requestFullscreen();
                    else if (target.webkitRequestFullscreen) target.webkitRequestFullscreen();
                } else {
                    if (document.exitFullscreen) await document.exitFullscreen();
                    else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
                }
            } catch (e) { console.warn('Fullscreen error:', e); }
        }
        function updateFsUi() { if (fsBtn) fsBtn.classList.toggle('active', isFullscreen()); }
        if (fsBtn) fsBtn.addEventListener('click', toggleFullscreen);
        document.addEventListener('fullscreenchange', updateFsUi);
        document.addEventListener('webkitfullscreenchange', updateFsUi);

        const toggleControlsBtn = document.getElementById('toggle-controls-btn');
        const controlsPanel = document.getElementById('controls-panel');
        toggleControlsBtn.addEventListener('click', () => {
            controlsPanel.classList.toggle('active');
            onWindowResize();
        });

        const toggleNamesBtn = document.getElementById('toggle-names-btn');
        toggleNamesBtn.addEventListener('click', () => {
            showNoteNames = !showNoteNames;
            toggleNamesBtn.classList.toggle('active', showNoteNames);
            musicalObjects.forEach(obj => {
                const label = document.getElementById(`label-${obj.userData.id}`);
                if (label) {
                    label.style.opacity = showNoteNames ? '1' : '0';
                }
            });
        });

        const helpBtn = document.getElementById('help-btn');
        const helpScreen = document.getElementById('help-screen');

        helpBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            helpScreen.style.visibility = 'visible';
            helpScreen.style.opacity = '1';
        });

        helpScreen.addEventListener('click', () => {
            helpScreen.style.opacity = '0';
            helpScreen.style.visibility = 'hidden';
        });

        const rotationSlider = document.getElementById('rotation-speed');
        rotationSlider.addEventListener('input', (e) => {
            rotationSpeed = parseFloat(e.target.value);
        });
    }

    // Helper to get normalized audio parameters from 3D world position
    function map3DToAudioParams(worldPos) {
        const xRange = 20; // -10 to 10 in scene X
        const yRange = 12; // -2 to 10 in scene Y
        const zRange = 20; // -10 to 10 in scene Z

        const normX = THREE.MathUtils.clamp((worldPos.x + xRange / 2) / xRange, 0, 1) * 2 - 1; // -1 to 1
        const normY = THREE.MathUtils.clamp((worldPos.y + 2) / yRange, 0, 1) * 2 - 1; // -1 to 1
        const normZ = THREE.MathUtils.clamp((worldPos.z + zRange / 2) / zRange, 0, 1) * 2 - 1; // -1 to 1
        const radiusXZ = Math.hypot(worldPos.x, worldPos.z) / 10; // Normalize distance from center XZ plane 0-1

        return { x: normX, y: normY, z: normZ, r: radiusXZ };
    }

    function handleObjectClick(object) {
        if (!object.userData) return;

        // Lazily create Voice object if it doesn't exist
        if (!object.userData.voice) {
            const worldPos = object.getWorldPosition(new THREE.Vector3());
            const { x: nx, y: ny, z: nz, r: nr } = map3DToAudioParams(worldPos);
            object.userData.voice = new Voice(nx, ny, nz, nr);
        }

        const worldPos = object.getWorldPosition(new THREE.Vector3());
        const { x: nx, y: ny, z: nz, r: nr } = map3DToAudioParams(worldPos);

        object.userData.voice.updateParameters(nx, ny, nz, nr);
        animateObjectActivation(object);
        
        createWavePropagation(object.position, BASE_FREQ * Math.pow(2, ny * 2));
        showHarmonicConnections(object, BASE_FREQ * Math.pow(2, ny * 2));
        updateInfoDisplay(BASE_FREQ * Math.pow(2, ny * 2), nx, nz, object.userData.noteIndex);
    }

    // Update Voice parameters from object's current 3D position
    function updateVoiceParametersFromObject(object) {
        if (!object.userData || !object.userData.voice) return; // Only update if voice exists

        const worldPos = object.getWorldPosition(new THREE.Vector3());
        const { x: nx, y: ny, z: nz, r: nr } = map3DToAudioParams(worldPos);

        object.userData.voice.updateParameters(nx, ny, nz, nr);
        updateInfoDisplay(BASE_FREQ * Math.pow(2, ny * 2), nx, nz, object.userData.noteIndex);
    }

    /* ====== VISUAL FEEDBACK ====== */
    function animateObjectActivation(object, color = 0xcc33ff) { // Neon purple for activation
        object.children.forEach(child => {
            if (child.material) {
                if (child.material.emissive) {
                    child.material.emissive.setHex(color);
                    setTimeout(() => child.material.emissive.setHex(0x000000), 500); // Fade emissive color
                }
                if (child.material.color) {
                    const originalColor = child.material.color.clone();
                    child.material.color.setHex(color);
                    setTimeout(() => child.material.color.copy(originalColor), 500); // Fade base color
                }
            }
        });

        animateProperty({ scale: 1 }, { scale: 1.3 }, 200, (values) => {
            object.scale.setScalar(values.scale);
        }, () => {
            animateProperty({ scale: 1.3 }, { scale: 1 }, 300, (values) => {
                object.scale.setScalar(values.scale);
            });
        });
    }

    function createWavePropagation(origin, frequency) {
        const geometry = new THREE.BufferGeometry();
        const material = new THREE.LineBasicMaterial({ color: 0x8a2be2, linewidth: 2, transparent: true, blending: THREE.AdditiveBlending });
        const line = new THREE.Line(geometry, material);
        line.position.copy(origin);
        line.lookAt(camera.position); // Face the camera

        const startTime = Date.now();
        const duration = 2000;

        const animateWave = () => {
            const elapsed = Date.now() - startTime;
            const progress = elapsed / duration;
            if (progress > 1) { turntableGroup.remove(line); return; }

            const newPoints = [];
            for (let i = 0; i < 200; i++) {
                const angle = (i / 200) * Math.PI * 2 * (frequency / 100);
                const x = (i - 100) * 0.1;
                const y = Math.sin(angle) * 2 * (1 - progress);
                newPoints.push(new THREE.Vector3(x, y, 0));
            }
            line.geometry.setFromPoints(newPoints);
            line.position.z -= progress * 5; // Move wave forward
            requestAnimationFrame(animateWave);
        };
        turntableGroup.add(line);
        animateWave();
    }

    function showHarmonicConnections(activeObject, frequency) {
        connections.forEach(conn => turntableGroup.remove(conn));
        connections = [];

        musicalObjects.forEach(obj => {
            if (obj === activeObject || obj.userData.type !== 'figure' || !obj.userData.voice) return; // Only connect active voices

            const objBaseFreq = obj.userData.voice.children[0]?.baseHz || BASE_FREQ; // Use actual voice base freq
            const ratio = frequency / objBaseFreq;

            const harmonicRatios = [1, 2, 1.5, 1.25, 4 / 3, 3 / 2, 5 / 4]; // Common harmonic ratios
            let strength = 0;

            harmonicRatios.forEach(r => {
                const difference = Math.abs(ratio - r);
                const inverseDifference = Math.abs(1 / ratio - r);
                if (difference < 0.1 || inverseDifference < 0.1) {
                    strength = Math.max(strength, 1 - Math.min(difference, inverseDifference) * 10);
                }
            });

            if (strength > 0) {
                const connection = createHarmonicConnection(activeObject.position, obj.position, strength);
                turntableGroup.add(connection);
                connections.push(connection);
            }
        });

        setTimeout(() => {
            connections.forEach(conn => turntableGroup.remove(conn));
            connections = [];
        }, 2000);
    }

    function createHarmonicConnection(pos1, pos2, strength) {
        const points = [];
        const distance = pos1.distanceTo(pos2);
        const midpoint = new THREE.Vector3().addVectors(pos1, pos2).multiplyScalar(0.5);
        midpoint.y += distance * 0.3; // Arc up

        for (let i = 0; i <= 20; i++) {
            const t = i / 20;
            const point = new THREE.Vector3();
            point.lerpVectors(pos1, pos2, t);
            point.y += Math.sin(t * Math.PI) * distance * 0.3 * strength;
            points.push(point);
        }

        const curve = new THREE.CatmullRomCurve3(points);
        const geometry = new THREE.TubeGeometry(curve, 20, 0.05 + strength * 0.1, 8, false);
        const material = new THREE.MeshBasicMaterial({ color: 0xcc33ff, transparent: true, opacity: 0.2 + strength * 0.8, blending: THREE.AdditiveBlending }); // Neon purple
        
        return new THREE.Mesh(geometry, material);
    }

    function updateInfoDisplay(frequency, xFactor, zFactor, noteIndex) {
        const pitchMidi = hzToMidi(frequency);
        const midiNote = Math.round(pitchMidi % 12);
        const noteName = noteNames[midiNote];
        const panValue = xFactor.toFixed(2);
        const filterValue = (BASE_CUTOFF * (1 + ((zFactor + 1) / 2) * 0.5)).toFixed(0); // Approx filter value

        const infoOverlay = document.getElementById('info-overlay');
        infoOverlay.textContent = `Note: ${noteName} (${frequency.toFixed(2)} Hz) | Pan: ${panValue} | Filter: ${filterValue} Hz`;
        infoOverlay.style.opacity = '1';

        setTimeout(() => {
            infoOverlay.style.opacity = '0';
        }, 2000);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    function animateThreeJS() {
        requestAnimationFrame(animateThreeJS);

        // Apply turntable rotation
        turntableGroup.rotation.y += turntableAngularVelocity + rotationSpeed;
        turntableAngularVelocity *= 0.96; // Damping

        musicalObjects.forEach((obj) => {
            if (obj.userData && obj.userData.originalPosition) {
                const label = document.getElementById(`label-${obj.userData.id}`);
                if (label) {
                    const vector = new THREE.Vector3();
                    const worldPos = obj.getWorldPosition(vector);
                    worldPos.project(camera);
                    const x = (worldPos.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-worldPos.y * 0.5 + 0.5) * window.innerHeight;
                    label.style.left = `${x}px`;
                    label.style.top = `${y}px`;
                }
            }
        });

        // Keep backboard static relative to camera
        backboardGroup.position.copy(camera.position);
        const forward = new THREE.Vector3();
        camera.getWorldDirection(forward);
        forward.multiplyScalar(12); // Distance in front of camera
        backboardGroup.position.add(forward);
        backboardGroup.lookAt(camera.position.clone().add(forward));
        backboardGroup.rotation.y += Math.PI; // Correct orientation to face camera

        camera.lookAt(0, 4, 0); // Always look at the center of the scene
        
        renderer.render(scene, camera);
    }
    
    function animateProperty(from, to, duration, onUpdate, onComplete) {
        const start = performance.now();
        function tick(now) {
            const elapsed = now - start;
            const progress = Math.min(elapsed / duration, 1);
            const values = {};
            for (const key in from) {
                values[key] = from[key] + (to[key] - from[key]) * progress;
            }
            onUpdate(values);
            if (progress < 1) {
                requestAnimationFrame(tick);
            } else if (onComplete) {
                onComplete();
            }
        }
        requestAnimationFrame(tick);
    }
    
    function addNoteLabels() {
        musicalObjects.forEach(obj => {
            if (obj.userData) {
                const labelDiv = document.createElement('div');
                labelDiv.className = 'note-label';
                labelDiv.id = `label-${obj.userData.id}`;
                labelDiv.textContent = noteNames[obj.userData.noteIndex % noteNames.length]; // Simple C-major scale mapping for display
                document.body.appendChild(labelDiv);
            }
        });
    }
    
    // Initial setup on window load
    window.onload = () => {
        init();
    };
</script>
</body>
</html>